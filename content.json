{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Gyan","url":"https://gy4n.github.io","root":"/"},"pages":[{"title":"about","date":"1970-01-01T00:00:00.000Z","updated":"2023-05-09T05:16:55.840Z","comments":true,"path":"about/index.html","permalink":"https://gy4n.github.io/about/index.html","excerpt":"","text":"Gyan，每天都在和Microsoft斗智斗勇。"}],"posts":[{"title":"UEFI+MBR调试踩坑合集","slug":"UEFI-MBR调试踩坑合集","date":"2023-05-09T06:10:13.000Z","updated":"2023-05-09T08:14:39.505Z","comments":true,"path":"UEFI-MBR调试踩坑合集/","link":"","permalink":"https://gy4n.github.io/UEFI-MBR%E8%B0%83%E8%AF%95%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/","excerpt":"记录一下UEFI + MBR 相关环境搭建上踩过的坑。","text":"记录一下UEFI + MBR 相关环境搭建上踩过的坑。 关闭Hyper-V在最新的Windows环境上，可能需要关闭Hyper-V，才能在VMware的虚拟机配置-处理器-虚拟化引擎中选中Intel VT-x/EPT 如果开启了Virtualization Based Security（基于虚拟化的安全性），请先关闭它 1reg ADD HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\DeviceGuard /v EnableVirtualizationBasedSecurity /t REG_DWORD /d 0 /f 再关闭Hyper-V 1bcdedit /set hypervisorlaunchtype off 如果只关闭Hyper-V，不关闭VBS，Hyper-V是关不掉的，我不知道为什么。 Vmware + IDA 调试请关闭Hyper-V 配置以下参数到VMX里面 1234debugStub.listen.guest32 = &quot;TRUE&quot;debugStub.hideBreakpoints = &quot;TRUE&quot;monitor.debugOnStartGuest32 = &quot;TRUE&quot;bios.bootDelay = &quot;10000&quot; 使用ida的IDA--&gt; Debugger--&gt; Attach--&gt; Remote GDB debugger 连接127.0.0.1:8832端口，启动虚拟机，之后在IDA弹出的窗口选择第一个。 按alt+s更改段为16位，给0x7c00下断点。 EDK2 + Windbg 调试因为目前的博客的介绍EDK2 + Windbg 调试的时间都在2020年，所以： 切换分支到202002的这个tag，回退版本到2020年。就可以支持Windbg + EDK2 的调试了。","categories":[],"tags":[{"name":"坑","slug":"坑","permalink":"https://gy4n.github.io/tags/%E5%9D%91/"},{"name":"调试","slug":"调试","permalink":"https://gy4n.github.io/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"VT 技术学习","slug":"VT-技术学习","date":"2023-02-05T07:58:19.000Z","updated":"2023-05-09T08:13:49.615Z","comments":true,"path":"VT-技术学习/","link":"","permalink":"https://gy4n.github.io/VT-%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"VT 技术0x00 VT 技术介绍0x01 VT 环境搭建在最新的Windows环境上，可能需要关闭Hyper-V，才能在VMware的虚拟机配置-处理器-虚拟化引擎中选中Intel VT-x/EPT 如果开启了Virtualization Based Security（基于虚拟化的安全性），请先关闭它 1reg ADD HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\DeviceGuard /v EnableVirtualizationBasedSecurity /t REG_DWORD /d 0 /f 再关闭Hyper-V 1bcdedit /set hypervisorlaunchtype off 如果只关闭Hyper-V，不关闭VBS，Hyper-V是关不掉的。如果还开启了UEFI 锁等复杂情况，就要参考微软文档了。 0x02 总体流程0x03 前置工作CPUIDeax = 1执行CPUID，ecx[5] = 1则支持VT-x 1234567int ret[4]; __cpuid(ret, 1); // 检查是否支持VT if (!(ret[2] &amp; 0x20)) &#123; // cpuid(1).ecx[5] == 1 return FALSE; &#125; msr检查VT-x是否在BIOS中被开启msr[0x3a]结果中的最低为为lock位，需要置1 1234uint64_t msr = __readmsr(0x3a);if (!(msr &amp; 1)) &#123; // msr[0x3a].lock == 1 return FALSE;&#125; CR4CR4中的第13位VMXE置1打开启用VMXE指令扩展 12345uintptr_t cr4 = __readcr4();// 检查VT-x 是否已经开启if (cr4 &amp; 0x2000) &#123; //cr4.VMXE == 0 return FALSE;&#125; 0x04 VMXON启用VMX扩展123456void inline EnableVMXE()&#123; uint32_t cr4 = __readcr4(); cr4 &amp;= ~0x2000; __writecr4(cr4);&#125; 分配VMXON 区域直接分配4k即可 1234PHYSICAL_ADDRESS HighAddress = &#123; 0 &#125;;g_cpu.pVMXONRegion = ExAllocatePoolWithTag(NonPagedPool, 0x1000, &#x27;vmon&#x27;);g_cpu.pVMXONRegion_PA = MmGetPhysicalAddress(g_cpu.pVMXONRegion);RtlZeroMemory(g_cpu.pVMXONRegion, 0x1000); 设置VMXON区域设置VMXON区域的四字节为msr[0x480]的低32位 123uintptr_t msr = __readmsr(0x480);*(ULONG*)(g_cpu.pVMXONRegion) = msr &amp; 0xffffffff; 执行VMXON指令，出错则CF位置1 12345push _highpush _lowvmxon dword ptr [esp]setc eaxadd esp,8 0x05 VMCSVMCS是Virtual Machine Control Structure，描述VM的一些属性。 首先需要初始化VMCS，再选中此VMCS。 1234// 初始化虚拟机__vmx_vmclear(*(uint64_t*)(&amp;g_cpu.pVMCSRegion_PA));// 选中此虚拟机__vmx_vmptrld(*(uint64_t*)(&amp;g_cpu.pVMCSRegion_PA)); Intel 弄了一个标准的汇编指令来读写VMCS，vmwrite/vmread，不推荐直接修改内存。 VMCS域 包括以下三方面的内容： 1.宿主机执行域 2.虚拟机执行域 3.虚拟机执行控制域 3.1 VM 执行控制(#VMExit 事件设置)44 3.2 VM 退出控制(#VMExit 保存内容设置) 3.3 VM 进入控制(进入#VMEntry 加载设置) 宿主机执行域 获取段描述符基址 1234567891011PVOID GetSegmentDescriptor(uint16_t index)&#123; KGDTENTRY* GdtEntry = Asm_GetGdtBase(); KGDTENTRY TargetEntry = GdtEntry[index &gt;&gt; 3]; uintptr_t ret = TargetEntry.HighWord.Bytes.BaseHi; ret &lt;&lt;= 8; ret |= TargetEntry.HighWord.Bytes.BaseMid; ret &lt;&lt;= 16; ret |= TargetEntry.BaseLow; return (PVOID)ret;&#125; HOST_RSP的值，需要提前申请 &amp; 0xfff8必须清除RPL，和TI 123456789101112131415161718192021222324252627__vmx_vmwrite(HOST_CR0, __readcr0());__vmx_vmwrite(HOST_CR3, __readcr3());__vmx_vmwrite(HOST_CR4, __readcr4());__vmx_vmwrite(HOST_ES_SELECTOR, GetES() &amp; 0xFFF8);__vmx_vmwrite(HOST_CS_SELECTOR, GetCS() &amp; 0xFFF8);__vmx_vmwrite(HOST_DS_SELECTOR, GetDS() &amp; 0xFFF8);__vmx_vmwrite(HOST_FS_SELECTOR, GetFS() &amp; 0xFFF8);__vmx_vmwrite(HOST_GS_SELECTOR, GetGS() &amp; 0xFFF8);__vmx_vmwrite(HOST_SS_SELECTOR, GetSS() &amp; 0xFFF8);__vmx_vmwrite(HOST_TR_SELECTOR, GetTR() &amp; 0xFFF8);// KGDTENTRY* GdtEntry = Asm_GetGdtBase();__vmx_vmwrite(HOST_TR_BASE, 0x80042000);__vmx_vmwrite(HOST_GDTR_BASE, Asm_GetGdtBase());__vmx_vmwrite(HOST_IDTR_BASE, Asm_GetIdtBase());__vmx_vmwrite(HOST_IA32_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS) &amp; 0xFFFFFFFF);__vmx_vmwrite(HOST_IA32_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP) &amp; 0xFFFFFFFF);__vmx_vmwrite(HOST_IA32_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP) &amp; 0xFFFFFFFF); // KiFastCallEntry__vmx_vmwrite(HOST_RSP, ((ULONG)g_VMXCPU.pStack) + 0x2000); //Host 临时栈__vmx_vmwrite(HOST_RIP, (ULONG)VMMEntryPoint); //这里定义我们的VMM处理程序入口 很好，Intel你要提供HOST_TR_BASE，HOST_FS_BASE，HOST_GS_BASE 如果要它的话需要在GDT表找，然后拼接基地址。 这里偷了一份KGDTEntry的结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970typedef struct _KGDTENTRY&#123; USHORT LimitLow; //0x0 USHORT BaseLow; //0x2 union &#123; struct &#123; UCHAR BaseMid; //0x4 UCHAR Flags1; //0x5 UCHAR Flags2; //0x6 UCHAR BaseHi; //0x7 &#125; Bytes; //0x4 struct &#123; ULONG BaseMid : 8; //0x4 ULONG Type : 5; //0x4 ULONG Dpl : 2; //0x4 ULONG Pres : 1; //0x4 ULONG LimitHi : 4; //0x4 ULONG Sys : 1; //0x4 ULONG Reserved_0 : 1; //0x4 ULONG Default_Big : 1; //0x4 ULONG Granularity : 1; //0x4 ULONG BaseHi : 8; //0x4 &#125; Bits; //0x4 &#125; HighWord; //0x4&#125; KGDTENTRY;#else//0x10 bytes (sizeof)typedef union _KGDTENTRY&#123; struct &#123; USHORT LimitLow; //0x0 USHORT BaseLow; //0x2 &#125;; struct &#123; UCHAR BaseMiddle; //0x4 UCHAR Flags1; //0x5 UCHAR Flags2; //0x6 UCHAR BaseHigh; //0x7 &#125; Bytes; //0x4 struct &#123; struct &#123; ULONG BaseMiddle : 8; //0x4 ULONG Type : 5; //0x4 ULONG Dpl : 2; //0x4 ULONG Present : 1; //0x4 ULONG LimitHigh : 4; //0x4 ULONG System : 1; //0x4 ULONG LongMode : 1; //0x4 ULONG DefaultBig : 1; //0x4 ULONG Granularity : 1; //0x4 ULONG BaseHigh : 8; //0x4 &#125; Bits; //0x4 ULONG BaseUpper; //0x8 &#125;; struct &#123; ULONG MustBeZero; //0xc LONGLONG DataLow; //0x0 &#125;; LONGLONG DataHigh; //0x8&#125;KGDTENTRY; 虚拟机执行控制域 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455`GUEST_ES_AR_BYTES`为ES段的属性，设置为`0x10000`不可用。```c__vmx_vmwrite(GUEST_CR0, __readcr0());__vmx_vmwrite(GUEST_CR3, __readcr3());__vmx_vmwrite(GUEST_CR4, __readcr4());__vmx_vmwrite(GUEST_DR7, 0x400);__vmx_vmwrite(GUEST_RFLAGS, __readeflags() &amp; ~0x200); // IF = 0__vmx_vmwrite(GUEST_ES_SELECTOR, GetES() &amp; 0xFFF8);__vmx_vmwrite(GUEST_CS_SELECTOR, GetCS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_DS_SELECTOR, GetDS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_FS_SELECTOR, GetFS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_GS_SELECTOR, GetGS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_SS_SELECTOR, GetSS() &amp; 0xFFF8);__vmx_vmwrite(GUEST_TR_SELECTOR, GetTR() &amp; 0xFFF8);// 设置 Segment Unusable__vmx_vmwrite(GUEST_ES_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_FS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_DS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_SS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_GS_AR_BYTES, 0x10000);__vmx_vmwrite(GUEST_LDTR_AR_BYTES, 0x10000);// 需要构造描述符线长、属性等，我要偷大懒// 在guest里面刷一下选择子__vmx_vmwrite(GUEST_CS_AR_BYTES, 0xc09b);__vmx_vmwrite(GUEST_CS_BASE, 0);__vmx_vmwrite(GUEST_CS_LIMIT, 0xffffffff);__vmx_vmwrite(GUEST_TR_AR_BYTES, 0x008b);__vmx_vmwrite(GUEST_TR_BASE, 0x80042000);__vmx_vmwrite(GUEST_TR_LIMIT, 0x20ab);__vmx_vmwrite(GUEST_GDTR_BASE, Asm_GetGdtBase());__vmx_vmwrite(GUEST_GDTR_LIMIT, Asm_GetGdtLimit());__vmx_vmwrite(GUEST_IDTR_BASE, Asm_GetIdtBase());__vmx_vmwrite(GUEST_IDTR_LIMIT, Asm_GetIdtLimit());__vmx_vmwrite(GUEST_IA32_DEBUGCTL, __readmsr(MSR_IA32_DEBUGCTL) &amp; 0xFFFFFFFF);__vmx_vmwrite(GUEST_IA32_DEBUGCTL_HIGH, __readmsr(MSR_IA32_DEBUGCTL) &gt;&gt; 32);__vmx_vmwrite(GUEST_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS) &amp; 0xFFFFFFFF);__vmx_vmwrite(GUEST_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP) &amp; 0xFFFFFFFF);__vmx_vmwrite(GUEST_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP) &amp; 0xFFFFFFFF); // KiFastCallEntry__vmx_vmwrite(GUEST_RSP, ((ULONG)g_cpu.pStack) + 0x1000); //Guest 临时栈__vmx_vmwrite(GUEST_RIP, (ULONG)GuestEntry); // 客户机的入口点// 物理地址意义上的nullptr__vmx_vmwrite(VMCS_LINK_POINTER, 0xffffffff);__vmx_vmwrite(VMCS_LINK_POINTER_HIGH, 0xffffffff); GuestEntry是GUEST VM的入口点 __vmx_vmread(VM_INSTRUCTION_ERROR)@24.9.1 VM 控制域 通过设置Flags标志位来控制VM的一些行为，Intel为了防止你写玩具VMM的时候把这段全填0，贴心的设置了一些预留位需要置1的位，真好。 通过查询MSR寄存器来了解哪些预留位为1，哪些为0 比如 123456789101112kd&gt; rdmsr 481msr[481] = 0000003f`00000016kd&gt; .formats 0000003f`00000016Evaluate expression: Hex: 0000003f`00000016 Decimal: 270582939670 Octal: 0000000003740000000026 Binary: 00000000 00000000 00000000 00111111 00000000 00000000 00000000 00010110 Chars: ...?.... Time: Mon Jan 1 15:30:58.293 1601 (UTC + 8:00) Float: low 3.08286e-044 high 8.82818e-044 Double: 1.33686e-312 MSR值中前32位中二进制为0的位，设置对应域时该位必须为0 MSR值中后32位中二进制为1的位，设置对应域时该位必须为1 1234567ULONG VTAdjustExcuteControls(ULONG Value,ULONG msr)&#123; uint64_t mask = __readmsr(msr); Value &amp;= (mask &gt;&gt; 32); Value |= (mask &amp; 0xffffffff); return Value;&#125; VM 执行控制 Pin-Based VM-Execution Controls 基于CPU针脚的VM执行控制 （Intel 3a @24.6.1） 定义发生外部中断、NMI等的是否退出虚拟机。 1__vmx_vmwrite(PIN_BASED_VM_EXEC_CONTROL, VTAdjustExcuteControls(0, MSR_IA32_VMX_PINBASED_CTLS)); Processor-Based VM-Execution Controls 基于处理器的VM执行控制（Intel 3a @24.6.2） 定义执行一些CPU指令（HLT/INVLPG/RDTSC/CR3切换/内部中断）是否需要退出虚拟机 1__vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL, VTAdjustExcuteControls(0, MSR_IA32_VMX_PROCBASED_CTLS)); VM 退出控制 Intel &#51;&#x61;&#x40;&#x32;&#52;&#46;&#55;&#x2e;&#x31; 1__vmx_vmwrite(VM_EXIT_CONTROLS, VTAdjustExcuteControls(0,MSR_IA32_VMX_EXIT_CTLS)); VM 进入控制 Intel &#51;&#x61;&#64;&#50;&#52;&#x2e;&#55;&#46;&#49; 1__vmx_vmwrite(VM_ENTRY_CONTROLS, VTAdjustExcuteControls(0, MSR_IA32_VMX_ENTRY_CTLS)); 0x06 VM 启动启动后，CPU会跳到GUEST_RIP，ESP设置为GUEST_RSP 12345678910111213141516171819__asm&#123; pushad pushfd mov guest_sp,esp mov guest_ip, offset Ret&#125;// VMLANUCH 虚拟机启动，跳转到 GuestEntry 就不回来了__vmx_vmlaunch();// 这条指令下的语句不会执行DbgPrint(&quot;VT Failed With Error Code: 0x%x&quot;,__vmx_vmread(VM_INSTRUCTION_ERROR));// 这里的Ret是用来接收跳转，正常返回Ret: __asm&#123; popfd popad &#125; GuestEntry的定义 123456789101112131415161718192021222324252627__declspec(naked) void GuestEntry(void)&#123; __asm &#123; mov ax, es mov es, ax mov ax, ds mov ds, ax mov ax, fs mov fs, ax mov ax, gs mov gs, ax mov ax, ss mov ss, ax &#125; __asm &#123; mov esp, guest_sp jmp guest_ip &#125;&#125; 0x06 #VMExit当虚拟机执行到设置的#VMExit的指令后，会退出虚拟机，执行HOST_RIP函数。 1234567891011121314151617181920212223242526272829303132333435363738__declspec(naked) void VMExitHandler(void)&#123; __asm &#123; mov g_GuestRegs.eax, eax mov g_GuestRegs.ecx, ecx mov g_GuestRegs.edx, edx mov g_GuestRegs.ebx, ebx mov g_GuestRegs.esp, esp mov g_GuestRegs.ebp, ebp mov g_GuestRegs.esi, esi mov g_GuestRegs.edi, edi pushfd pop eax mov g_GuestRegs.eflags, eax mov ax, fs mov fs, ax mov ax, gs mov gs, ax &#125; VMExitHandlerDispatcher(); __asm &#123; mov eax, g_GuestRegs.eax mov ecx, g_GuestRegs.ecx mov edx, g_GuestRegs.edx mov ebx, g_GuestRegs.ebx mov esp, g_GuestRegs.esp mov ebp, g_GuestRegs.ebp mov esi, g_GuestRegs.esi mov edi, g_GuestRegs.edi //vmresume __emit 0x0f __emit 0x01 __emit 0xc3 &#125;&#125; VMExitHandlerDispatcher函数用于处理#VMExit事件： ExitReason指定了退出原因。 ExitInstructionLength指定了导致退出指令的长度。 g_GuestRegs.eip = __vmx_vmread(GUEST_RIP);读取了导致退出指令的地址。 处理完指令的退出后，设置GUEST_RIP为下一跳指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void VMExitHandlerDispatcher(void)&#123; ULONG ExitReason; ULONG ExitInstructionLength; ULONG GuestResumeEIP; ExitReason = __vmx_vmread(VM_EXIT_REASON); ExitInstructionLength = __vmx_vmread(VM_EXIT_INSTRUCTION_LEN); g_GuestRegs.eflags = __vmx_vmread(GUEST_RFLAGS); g_GuestRegs.esp = __vmx_vmread(GUEST_RSP); g_GuestRegs.eip = __vmx_vmread(GUEST_RIP); switch (ExitReason) &#123; case EXIT_REASON_CPUID: HandleCPUID(); Log(&quot;EXIT_REASON_CPUID&quot;, 0) break; case EXIT_REASON_VMCALL: HandleVmCall(); Log(&quot;EXIT_REASON_VMCALL&quot;, 0) break; case EXIT_REASON_CR_ACCESS: HandleCrAccess(); //Log(&quot;EXIT_REASON_CR_ACCESS&quot;, 0) break; case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: break; default: Log(&quot;not handled reason: %p&quot;, ExitReason); __asm int 3 &#125; //Resume: GuestResumeEIP = g_GuestRegs.eip + ExitInstructionLength; __vmx_vmwrite(GUEST_RIP, GuestResumeEIP); __vmx_vmwrite(GUEST_RSP, g_GuestRegs.esp); __vmx_vmwrite(GUEST_RFLAGS, g_GuestRegs.eflags);&#125; 0x07 EPT看了一下要重建页表我就不想看了。 0x08 代码这个代码魔改的周壑的VT_Learn，建议不要乱魔改，坑非常多。","categories":[],"tags":[{"name":"VT","slug":"VT","permalink":"https://gy4n.github.io/tags/VT/"}]},{"title":"fiddler证书有效期时长设置","slug":"fiddler证书有效期时长设置","date":"2021-12-16T01:05:44.000Z","updated":"2023-05-09T08:17:16.131Z","comments":true,"path":"fiddler证书有效期时长设置/","link":"","permalink":"https://gy4n.github.io/fiddler%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE/","excerpt":"chromium 85 以后，2020-09-01 以后签发的HTTPS TLS 证书的有效期最多不超过398天，这导致fiddler默认的根证书无效，无法抓包。 Beginning with Chrome 85, TLS server certificates issued on or after 2020-09-01 00:00:00 UTC will be required to have a validity period of 398 days or less. This will only apply to TLS server certificates from CAs that are trusted in a default installation of Google Chrome, commonly known as “publicly trusted CAs”, and will not apply to locally-operated CAs that have been manually configured. Certificates that do not comply with this requirement will not work, and may cause webpages to fail to load or to render incorrectly. If a certificate that does not comply with this requirement is issued by a CA trusted in a default installation of Google Chrome, this will be treated as a failure to comply with the security policies necessary to being a trusted CA, and may result in the removal of trust of that CA’s certificates. 需要重新配置Fiddler的证书有效期。","text":"chromium 85 以后，2020-09-01 以后签发的HTTPS TLS 证书的有效期最多不超过398天，这导致fiddler默认的根证书无效，无法抓包。 Beginning with Chrome 85, TLS server certificates issued on or after 2020-09-01 00:00:00 UTC will be required to have a validity period of 398 days or less. This will only apply to TLS server certificates from CAs that are trusted in a default installation of Google Chrome, commonly known as “publicly trusted CAs”, and will not apply to locally-operated CAs that have been manually configured. Certificates that do not comply with this requirement will not work, and may cause webpages to fail to load or to render incorrectly. If a certificate that does not comply with this requirement is issued by a CA trusted in a default installation of Google Chrome, this will be treated as a failure to comply with the security policies necessary to being a trusted CA, and may result in the removal of trust of that CA’s certificates. 需要重新配置Fiddler的证书有效期。 打开Fiddler的选项-HTTPS页面，提示证书由CertMaker.dll签发。 把这个CertMaker.dll扔进dnspy里面看一下。 有两个字段控制了证书的生成时间。 在QuickExec 执行 about:config（Fiddler抓包界面下面的命令行）fiddler.certmaker.bc.ee.yearsvalid 是 有效年份fiddler.certmaker.bc.ee.CreatedDaysAgo 是 起始日期这里年份填1，起始日期填-7就行了","categories":[],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"https://gy4n.github.io/tags/Fiddler/"}]}],"categories":[],"tags":[{"name":"坑","slug":"坑","permalink":"https://gy4n.github.io/tags/%E5%9D%91/"},{"name":"调试","slug":"调试","permalink":"https://gy4n.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"VT","slug":"VT","permalink":"https://gy4n.github.io/tags/VT/"},{"name":"Fiddler","slug":"Fiddler","permalink":"https://gy4n.github.io/tags/Fiddler/"}]}