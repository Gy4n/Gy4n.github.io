<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UEFI+MBR调试踩坑合集</title>
      <link href="/UEFI-MBR%E8%B0%83%E8%AF%95%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/"/>
      <url>/UEFI-MBR%E8%B0%83%E8%AF%95%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>记录一下UEFI + MBR 相关环境搭建上踩过的坑。</p><span id="more"></span><h2 id="关闭Hyper-V"><a href="#关闭Hyper-V" class="headerlink" title="关闭Hyper-V"></a>关闭Hyper-V</h2><p>在最新的Windows环境上，可能需要关闭<code>Hyper-V</code>，才能在VMware的虚拟机配置-处理器-虚拟化引擎中选中<code>Intel VT-x/EPT</code></p><p>如果开启了Virtualization Based Security（基于虚拟化的安全性），请先关闭它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg ADD HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceGuard /v EnableVirtualizationBasedSecurity /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><p>再关闭<code>Hyper-V</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>如果只关闭Hyper-V，不关闭VBS，Hyper-V是关不掉的，我不知道为什么。</p><h2 id="Vmware-IDA-调试"><a href="#Vmware-IDA-调试" class="headerlink" title="Vmware + IDA 调试"></a>Vmware + IDA 调试</h2><p>请关闭<code>Hyper-V</code></p><p>配置以下参数到VMX里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debugStub.listen.guest32 = &quot;TRUE&quot;</span><br><span class="line">debugStub.hideBreakpoints = &quot;TRUE&quot;</span><br><span class="line">monitor.debugOnStartGuest32 = &quot;TRUE&quot;</span><br><span class="line">bios.bootDelay = &quot;10000&quot;</span><br></pre></td></tr></table></figure><p>使用ida的<code>IDA--&gt; Debugger--&gt; Attach--&gt; Remote GDB debugger</code></p><p>连接<code>127.0.0.1:8832</code>端口，启动虚拟机，之后在IDA弹出的窗口选择第一个。</p><p>按<code>alt+s</code>更改段为16位，给<code>0x7c00</code>下断点。</p><h2 id="EDK2-Windbg-调试"><a href="#EDK2-Windbg-调试" class="headerlink" title="EDK2 + Windbg 调试"></a>EDK2 + Windbg 调试</h2><p>因为目前的博客的介绍EDK2 + Windbg 调试的时间都在2020年，所以：</p><p>切换分支到<code>202002</code>的这个tag，回退版本到2020年。就可以支持Windbg + EDK2 的调试了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VT 技术学习</title>
      <link href="/VT-%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
      <url>/VT-%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="VT-技术"><a href="#VT-技术" class="headerlink" title="VT 技术"></a>VT 技术</h2><h3 id="0x00-VT-技术介绍"><a href="#0x00-VT-技术介绍" class="headerlink" title="0x00  VT 技术介绍"></a>0x00  VT 技术介绍</h3><h3 id="0x01-VT-环境搭建"><a href="#0x01-VT-环境搭建" class="headerlink" title="0x01 VT 环境搭建"></a>0x01 VT 环境搭建</h3><p>在最新的Windows环境上，可能需要关闭<code>Hyper-V</code>，才能在VMware的虚拟机配置-处理器-虚拟化引擎中选中<code>Intel VT-x/EPT</code></p><p>如果开启了Virtualization Based Security（基于虚拟化的安全性），请先关闭它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg ADD HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceGuard /v EnableVirtualizationBasedSecurity /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><p>再关闭<code>Hyper-V</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>如果只关闭Hyper-V，不关闭VBS，Hyper-V是关不掉的。<br>如果还开启了UEFI 锁等复杂情况，就要参考微软文档了。</p><h3 id="0x02-总体流程"><a href="#0x02-总体流程" class="headerlink" title="0x02 总体流程"></a>0x02 总体流程</h3><h3 id="0x03-前置工作"><a href="#0x03-前置工作" class="headerlink" title="0x03 前置工作"></a>0x03 前置工作</h3><h4 id="CPUID"><a href="#CPUID" class="headerlink" title="CPUID"></a>CPUID</h4><p><code>eax = 1</code>执行<code>CPUID</code>，<code>ecx[5] = 1</code>则支持VT-x</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">__cpuid(ret, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 检查是否支持VT</span></span><br><span class="line"><span class="keyword">if</span> (!(ret[<span class="number">2</span>] &amp; <span class="number">0x20</span>)) &#123; <span class="comment">// cpuid(1).ecx[5] == 1</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="msr"><a href="#msr" class="headerlink" title="msr"></a>msr</h4><p>检查VT-x是否在BIOS中被开启<br><code>msr[0x3a]</code>结果中的最低为为lock位，需要置1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> msr = __readmsr(<span class="number">0x3a</span>);</span><br><span class="line"><span class="keyword">if</span> (!(msr &amp; <span class="number">1</span>)) &#123; <span class="comment">//  msr[0x3a].lock == 1</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h4><p><code>CR4</code>中的第13位<code>VMXE</code>置1打开启用<code>VMXE</code>指令扩展</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> cr4 = __readcr4();</span><br><span class="line"><span class="comment">// 检查VT-x 是否已经开启</span></span><br><span class="line"><span class="keyword">if</span> (cr4 &amp; <span class="number">0x2000</span>) &#123; <span class="comment">//cr4.VMXE == 0</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x04-VMXON"><a href="#0x04-VMXON" class="headerlink" title="0x04 VMXON"></a>0x04 VMXON</h3><h4 id="启用VMX扩展"><a href="#启用VMX扩展" class="headerlink" title="启用VMX扩展"></a>启用VMX扩展</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">inline</span> <span class="title function_">EnableVMXE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> cr4 = __readcr4();</span><br><span class="line">cr4 &amp;= ~<span class="number">0x2000</span>;</span><br><span class="line">__writecr4(cr4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分配VMXON-区域"><a href="#分配VMXON-区域" class="headerlink" title="分配VMXON 区域"></a>分配VMXON 区域</h4><p>直接分配4k即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHYSICAL_ADDRESS HighAddress = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">g_cpu.pVMXONRegion = ExAllocatePoolWithTag(NonPagedPool, <span class="number">0x1000</span>, <span class="string">&#x27;vmon&#x27;</span>);</span><br><span class="line">g_cpu.pVMXONRegion_PA = MmGetPhysicalAddress(g_cpu.pVMXONRegion);</span><br><span class="line">RtlZeroMemory(g_cpu.pVMXONRegion, <span class="number">0x1000</span>);</span><br></pre></td></tr></table></figure><h4 id="设置VMXON区域"><a href="#设置VMXON区域" class="headerlink" title="设置VMXON区域"></a>设置VMXON区域</h4><p>设置VMXON区域的四字节为msr[0x480]的低32位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> msr = __readmsr(<span class="number">0x480</span>);</span><br><span class="line">*(ULONG*)(g_cpu.pVMXONRegion) = msr &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>VMXON</code>指令，出错则CF位置1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push _high</span><br><span class="line">push _low</span><br><span class="line">vmxon dword ptr [esp]</span><br><span class="line">setc eax</span><br><span class="line">add esp,8</span><br></pre></td></tr></table></figure><h3 id="0x05-VMCS"><a href="#0x05-VMCS" class="headerlink" title="0x05  VMCS"></a>0x05  VMCS</h3><p>VMCS是<code>Virtual Machine Control Structure</code>，描述VM的一些属性。</p><p>首先需要初始化VMCS，再选中此VMCS。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化虚拟机</span></span><br><span class="line">__vmx_vmclear(*(<span class="type">uint64_t</span>*)(&amp;g_cpu.pVMCSRegion_PA));</span><br><span class="line"><span class="comment">// 选中此虚拟机</span></span><br><span class="line">__vmx_vmptrld(*(<span class="type">uint64_t</span>*)(&amp;g_cpu.pVMCSRegion_PA));</span><br></pre></td></tr></table></figure><p>Intel 弄了一个标准的汇编指令来读写VMCS，<code>vmwrite/vmread</code>，不推荐直接修改内存。</p><p>VMCS域 包括以下三方面的内容：</p><p>1.宿主机执行域</p><p>2.虚拟机执行域</p><p>3.虚拟机执行控制域</p><p>3.1 VM 执行控制(<code>#VMExit</code> 事件设置)44</p><p>3.2 VM 退出控制(<code>#VMExit</code> 保存内容设置)</p><p>3.3 VM 进入控制(进入<code>#VMEntry</code> 加载设置)</p><ul><li><p>宿主机执行域</p><p>获取段描述符基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">GetSegmentDescriptor</span><span class="params">(<span class="type">uint16_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">KGDTENTRY* GdtEntry = Asm_GetGdtBase();</span><br><span class="line">KGDTENTRY TargetEntry = GdtEntry[index &gt;&gt; <span class="number">3</span>];</span><br><span class="line"><span class="type">uintptr_t</span> ret = TargetEntry.HighWord.Bytes.BaseHi;</span><br><span class="line">ret &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">ret |= TargetEntry.HighWord.Bytes.BaseMid;</span><br><span class="line">ret &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">ret |= TargetEntry.BaseLow;</span><br><span class="line"><span class="keyword">return</span> (PVOID)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HOST_RSP</code>的值，需要提前申请 </p><p><code>&amp; 0xfff8</code>必须清除RPL，和<code>TI</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmwrite(HOST_CR0, __readcr0());</span><br><span class="line">__vmx_vmwrite(HOST_CR3, __readcr3());</span><br><span class="line">__vmx_vmwrite(HOST_CR4, __readcr4());</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(HOST_ES_SELECTOR, GetES() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line">__vmx_vmwrite(HOST_CS_SELECTOR, GetCS() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line">__vmx_vmwrite(HOST_DS_SELECTOR, GetDS() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line">__vmx_vmwrite(HOST_FS_SELECTOR, GetFS() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line">__vmx_vmwrite(HOST_GS_SELECTOR, GetGS() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line">__vmx_vmwrite(HOST_SS_SELECTOR, GetSS() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line">__vmx_vmwrite(HOST_TR_SELECTOR, GetTR() &amp; <span class="number">0xFFF8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// KGDTENTRY* GdtEntry = Asm_GetGdtBase();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(HOST_TR_BASE, <span class="number">0x80042000</span>);</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(HOST_GDTR_BASE, Asm_GetGdtBase());</span><br><span class="line">__vmx_vmwrite(HOST_IDTR_BASE, Asm_GetIdtBase());</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(HOST_IA32_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS) &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">__vmx_vmwrite(HOST_IA32_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP) &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">__vmx_vmwrite(HOST_IA32_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP) &amp; <span class="number">0xFFFFFFFF</span>); <span class="comment">// KiFastCallEntry</span></span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(HOST_RSP, ((ULONG)g_VMXCPU.pStack) + <span class="number">0x2000</span>);     <span class="comment">//Host 临时栈</span></span><br><span class="line">__vmx_vmwrite(HOST_RIP, (ULONG)VMMEntryPoint);                  <span class="comment">//这里定义我们的VMM处理程序入口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很好，Intel你要提供<code>HOST_TR_BASE</code>，<code>HOST_FS_BASE</code>，<code>HOST_GS_BASE</code></p><p>如果要它的话需要在GDT表找，然后拼接基地址。</p><p>这里偷了一份KGDTEntry的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KGDTENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT LimitLow;                                                        <span class="comment">//0x0</span></span><br><span class="line">    USHORT BaseLow;                                                         <span class="comment">//0x2</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR BaseMid;                                                  <span class="comment">//0x4</span></span><br><span class="line">            UCHAR Flags1;                                                   <span class="comment">//0x5</span></span><br><span class="line">            UCHAR Flags2;                                                   <span class="comment">//0x6</span></span><br><span class="line">            UCHAR BaseHi;                                                   <span class="comment">//0x7</span></span><br><span class="line">        &#125; Bytes;                                                            <span class="comment">//0x4</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG BaseMid : <span class="number">8</span>;                                                <span class="comment">//0x4</span></span><br><span class="line">            ULONG Type : <span class="number">5</span>;                                                   <span class="comment">//0x4</span></span><br><span class="line">            ULONG Dpl : <span class="number">2</span>;                                                    <span class="comment">//0x4</span></span><br><span class="line">            ULONG Pres : <span class="number">1</span>;                                                   <span class="comment">//0x4</span></span><br><span class="line">            ULONG LimitHi : <span class="number">4</span>;                                                <span class="comment">//0x4</span></span><br><span class="line">            ULONG Sys : <span class="number">1</span>;                                                    <span class="comment">//0x4</span></span><br><span class="line">            ULONG Reserved_0 : <span class="number">1</span>;                                             <span class="comment">//0x4</span></span><br><span class="line">            ULONG Default_Big : <span class="number">1</span>;                                            <span class="comment">//0x4</span></span><br><span class="line">            ULONG Granularity : <span class="number">1</span>;                                            <span class="comment">//0x4</span></span><br><span class="line">            ULONG BaseHi : <span class="number">8</span>;                                                 <span class="comment">//0x4</span></span><br><span class="line">        &#125; Bits;                                                             <span class="comment">//0x4</span></span><br><span class="line">    &#125; HighWord;                                                             <span class="comment">//0x4</span></span><br><span class="line">&#125; KGDTENTRY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">KGDTENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        USHORT LimitLow;                                                    <span class="comment">//0x0</span></span><br><span class="line">        USHORT BaseLow;                                                     <span class="comment">//0x2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UCHAR BaseMiddle;                                                   <span class="comment">//0x4</span></span><br><span class="line">        UCHAR Flags1;                                                       <span class="comment">//0x5</span></span><br><span class="line">        UCHAR Flags2;                                                       <span class="comment">//0x6</span></span><br><span class="line">        UCHAR BaseHigh;                                                     <span class="comment">//0x7</span></span><br><span class="line">    &#125; Bytes;                                                                <span class="comment">//0x4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG BaseMiddle : <span class="number">8</span>;                                                 <span class="comment">//0x4</span></span><br><span class="line">            ULONG Type : <span class="number">5</span>;                                                       <span class="comment">//0x4</span></span><br><span class="line">            ULONG Dpl : <span class="number">2</span>;                                                        <span class="comment">//0x4</span></span><br><span class="line">            ULONG Present : <span class="number">1</span>;                                                    <span class="comment">//0x4</span></span><br><span class="line">            ULONG LimitHigh : <span class="number">4</span>;                                                  <span class="comment">//0x4</span></span><br><span class="line">            ULONG System : <span class="number">1</span>;                                                     <span class="comment">//0x4</span></span><br><span class="line">            ULONG LongMode : <span class="number">1</span>;                                                   <span class="comment">//0x4</span></span><br><span class="line">            ULONG DefaultBig : <span class="number">1</span>;                                                 <span class="comment">//0x4</span></span><br><span class="line">            ULONG Granularity : <span class="number">1</span>;                                                <span class="comment">//0x4</span></span><br><span class="line">            ULONG BaseHigh : <span class="number">8</span>;                                                   <span class="comment">//0x4</span></span><br><span class="line">        &#125; Bits;                                                                 <span class="comment">//0x4</span></span><br><span class="line">        ULONG BaseUpper;                                                    <span class="comment">//0x8</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG MustBeZero;                                                   <span class="comment">//0xc</span></span><br><span class="line">        LONGLONG DataLow;                                                   <span class="comment">//0x0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    LONGLONG DataHigh;                                                      <span class="comment">//0x8</span></span><br><span class="line">&#125;KGDTENTRY;</span><br></pre></td></tr></table></figure></li><li><p>虚拟机执行控制域</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">`GUEST_ES_AR_BYTES`为ES段的属性，设置为`0x10000`不可用。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">__vmx_vmwrite(GUEST_CR0, __readcr0());</span><br><span class="line">__vmx_vmwrite(GUEST_CR3, __readcr3());</span><br><span class="line">__vmx_vmwrite(GUEST_CR4, __readcr4());</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_DR7, 0x400);</span><br><span class="line">__vmx_vmwrite(GUEST_RFLAGS, __readeflags() &amp; ~0x200); // IF = 0</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_ES_SELECTOR, GetES() &amp; 0xFFF8);</span><br><span class="line">__vmx_vmwrite(GUEST_CS_SELECTOR, GetCS() &amp; 0xFFF8);</span><br><span class="line">__vmx_vmwrite(GUEST_DS_SELECTOR, GetDS() &amp; 0xFFF8);</span><br><span class="line">__vmx_vmwrite(GUEST_FS_SELECTOR, GetFS() &amp; 0xFFF8);</span><br><span class="line">__vmx_vmwrite(GUEST_GS_SELECTOR, GetGS() &amp; 0xFFF8);</span><br><span class="line">__vmx_vmwrite(GUEST_SS_SELECTOR, GetSS() &amp; 0xFFF8);</span><br><span class="line">__vmx_vmwrite(GUEST_TR_SELECTOR, GetTR() &amp; 0xFFF8);</span><br><span class="line"></span><br><span class="line">// 设置 Segment Unusable</span><br><span class="line">__vmx_vmwrite(GUEST_ES_AR_BYTES, 0x10000);</span><br><span class="line">__vmx_vmwrite(GUEST_FS_AR_BYTES, 0x10000);</span><br><span class="line">__vmx_vmwrite(GUEST_DS_AR_BYTES, 0x10000);</span><br><span class="line">__vmx_vmwrite(GUEST_SS_AR_BYTES, 0x10000);</span><br><span class="line">__vmx_vmwrite(GUEST_GS_AR_BYTES, 0x10000);</span><br><span class="line">__vmx_vmwrite(GUEST_LDTR_AR_BYTES, 0x10000);</span><br><span class="line"></span><br><span class="line">// 需要构造描述符线长、属性等，我要偷大懒</span><br><span class="line">// 在guest里面刷一下选择子</span><br><span class="line">__vmx_vmwrite(GUEST_CS_AR_BYTES, 0xc09b);</span><br><span class="line">__vmx_vmwrite(GUEST_CS_BASE, 0);</span><br><span class="line">__vmx_vmwrite(GUEST_CS_LIMIT, 0xffffffff);</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_TR_AR_BYTES, 0x008b);</span><br><span class="line">__vmx_vmwrite(GUEST_TR_BASE, 0x80042000);</span><br><span class="line">__vmx_vmwrite(GUEST_TR_LIMIT, 0x20ab);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_GDTR_BASE, Asm_GetGdtBase());</span><br><span class="line">__vmx_vmwrite(GUEST_GDTR_LIMIT, Asm_GetGdtLimit());</span><br><span class="line">__vmx_vmwrite(GUEST_IDTR_BASE, Asm_GetIdtBase());</span><br><span class="line">__vmx_vmwrite(GUEST_IDTR_LIMIT, Asm_GetIdtLimit());</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_IA32_DEBUGCTL, __readmsr(MSR_IA32_DEBUGCTL) &amp; 0xFFFFFFFF);</span><br><span class="line">__vmx_vmwrite(GUEST_IA32_DEBUGCTL_HIGH, __readmsr(MSR_IA32_DEBUGCTL) &gt;&gt; 32);</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS) &amp; 0xFFFFFFFF);</span><br><span class="line">__vmx_vmwrite(GUEST_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP) &amp; 0xFFFFFFFF);</span><br><span class="line">__vmx_vmwrite(GUEST_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP) &amp; 0xFFFFFFFF); // KiFastCallEntry</span><br><span class="line"></span><br><span class="line">__vmx_vmwrite(GUEST_RSP, ((ULONG)g_cpu.pStack) + 0x1000);     //Guest 临时栈</span><br><span class="line">__vmx_vmwrite(GUEST_RIP, (ULONG)GuestEntry);                     // 客户机的入口点</span><br><span class="line"></span><br><span class="line">// 物理地址意义上的nullptr</span><br><span class="line">__vmx_vmwrite(VMCS_LINK_POINTER, 0xffffffff);</span><br><span class="line">__vmx_vmwrite(VMCS_LINK_POINTER_HIGH, 0xffffffff);</span><br></pre></td></tr></table></figure><p><code>GuestEntry</code>是GUEST VM的入口点</p><p> <code>__vmx_vmread(VM_INSTRUCTION_ERROR)</code>@24.9.1</p><ul><li><p>VM 控制域</p><p>通过设置<code>Flags</code>标志位来控制VM的一些行为，Intel为了防止你写玩具VMM的时候把这段全填0，贴心的设置了一些预留位需要置1的位，真好。</p><p>通过查询MSR寄存器来了解哪些预留位为1，哪些为0</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr 481</span><br><span class="line">msr[481] = 0000003f`00000016</span><br><span class="line">kd&gt; .formats 0000003f`00000016</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     0000003f`00000016</span><br><span class="line">  Decimal: 270582939670</span><br><span class="line">  Octal:   0000000003740000000026</span><br><span class="line">  Binary:  00000000 00000000 00000000 00111111 00000000 00000000 00000000 00010110</span><br><span class="line">  Chars:   ...?....</span><br><span class="line">  Time:    Mon Jan  1 15:30:58.293 1601 (UTC + 8:00)</span><br><span class="line">  Float:   low 3.08286e-044 high 8.82818e-044</span><br><span class="line">  Double:  1.33686e-312</span><br></pre></td></tr></table></figure><p>MSR值中前32位中二进制为0的位，设置对应域时该位必须为0</p><p>MSR值中后32位中二进制为1的位，设置对应域时该位必须为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ULONG <span class="title function_">VTAdjustExcuteControls</span><span class="params">(ULONG Value,ULONG msr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> mask = __readmsr(msr);</span><br><span class="line">Value &amp;= (mask &gt;&gt; <span class="number">32</span>);</span><br><span class="line">Value |= (mask &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"><span class="keyword">return</span> Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>VM 执行控制</p><p><code>Pin-Based VM-Execution Controls</code> 基于CPU针脚的VM执行控制 （Intel 3a @24.6.1）</p><p>定义发生外部中断、NMI等的是否退出虚拟机。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmwrite(PIN_BASED_VM_EXEC_CONTROL, VTAdjustExcuteControls(<span class="number">0</span>, MSR_IA32_VMX_PINBASED_CTLS));</span><br></pre></td></tr></table></figure><p><code>Processor-Based VM-Execution Controls</code> 基于处理器的VM执行控制（Intel 3a @24.6.2）</p><p>定义执行一些CPU指令（<code>HLT/INVLPG/RDTSC/CR3切换/内部中断</code>）是否需要退出虚拟机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL, VTAdjustExcuteControls(<span class="number">0</span>, MSR_IA32_VMX_PROCBASED_CTLS));</span><br></pre></td></tr></table></figure></li><li><p>VM 退出控制 </p><p>Intel <a href="mailto:&#x33;&#97;&#64;&#50;&#52;&#x2e;&#55;&#46;&#x31;">&#x33;&#97;&#64;&#50;&#52;&#x2e;&#55;&#46;&#x31;</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmwrite(VM_EXIT_CONTROLS, VTAdjustExcuteControls(<span class="number">0</span>,MSR_IA32_VMX_EXIT_CTLS));</span><br></pre></td></tr></table></figure></li><li><p>VM 进入控制</p><p>Intel <a href="mailto:&#51;&#97;&#x40;&#x32;&#x34;&#x2e;&#55;&#x2e;&#49;">&#51;&#97;&#x40;&#x32;&#x34;&#x2e;&#55;&#x2e;&#49;</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmwrite(VM_ENTRY_CONTROLS, VTAdjustExcuteControls(<span class="number">0</span>, MSR_IA32_VMX_ENTRY_CTLS));</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="0x06-VM-启动"><a href="#0x06-VM-启动" class="headerlink" title="0x06 VM 启动"></a>0x06 VM 启动</h3><p>启动后，CPU会跳到<code>GUEST_RIP</code>，ESP设置为<code>GUEST_RSP</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__asm&#123;</span><br><span class="line">    pushad</span><br><span class="line">    pushfd</span><br><span class="line">    mov guest_sp,esp</span><br><span class="line">    mov guest_ip, offset Ret</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VMLANUCH 虚拟机启动，跳转到 GuestEntry 就不回来了</span></span><br><span class="line">__vmx_vmlaunch();</span><br><span class="line"><span class="comment">// 这条指令下的语句不会执行</span></span><br><span class="line">DbgPrint(<span class="string">&quot;VT Failed With Error Code: 0x%x&quot;</span>,__vmx_vmread(VM_INSTRUCTION_ERROR));</span><br><span class="line"><span class="comment">// 这里的Ret是用来接收跳转，正常返回</span></span><br><span class="line">Ret:</span><br><span class="line">__asm&#123;</span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>GuestEntry</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">GuestEntry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm &#123;</span><br><span class="line"></span><br><span class="line">mov ax, es</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">mov ax, ds</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov ax, fs</span><br><span class="line">mov fs, ax</span><br><span class="line"></span><br><span class="line">mov ax, gs</span><br><span class="line">mov gs, ax</span><br><span class="line"></span><br><span class="line">mov ax, ss</span><br><span class="line">mov ss, ax</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm &#123;</span><br><span class="line"></span><br><span class="line">mov esp, guest_sp</span><br><span class="line">jmp guest_ip</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0x06-VMExit"><a href="#0x06-VMExit" class="headerlink" title="0x06 #VMExit"></a>0x06 #VMExit</h3><p>当虚拟机执行到设置的<code>#VMExit</code>的指令后，会退出虚拟机，执行<code>HOST_RIP</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">VMExitHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm &#123;</span><br><span class="line">mov g_GuestRegs.eax, eax</span><br><span class="line">mov g_GuestRegs.ecx, ecx</span><br><span class="line">mov g_GuestRegs.edx, edx</span><br><span class="line">mov g_GuestRegs.ebx, ebx</span><br><span class="line">mov g_GuestRegs.esp, esp</span><br><span class="line">mov g_GuestRegs.ebp, ebp</span><br><span class="line">mov g_GuestRegs.esi, esi</span><br><span class="line">mov g_GuestRegs.edi, edi</span><br><span class="line"></span><br><span class="line">pushfd</span><br><span class="line">pop eax</span><br><span class="line">mov g_GuestRegs.eflags, eax</span><br><span class="line"></span><br><span class="line">mov ax, fs</span><br><span class="line">mov fs, ax</span><br><span class="line">mov ax, gs</span><br><span class="line">mov gs, ax</span><br><span class="line">&#125;</span><br><span class="line">VMExitHandlerDispatcher();</span><br><span class="line">__asm &#123;</span><br><span class="line">mov  eax, g_GuestRegs.eax</span><br><span class="line">mov  ecx, g_GuestRegs.ecx</span><br><span class="line">mov  edx, g_GuestRegs.edx</span><br><span class="line">mov  ebx, g_GuestRegs.ebx</span><br><span class="line">mov  esp, g_GuestRegs.esp</span><br><span class="line">mov  ebp, g_GuestRegs.ebp</span><br><span class="line">mov  esi, g_GuestRegs.esi</span><br><span class="line">mov  edi, g_GuestRegs.edi</span><br><span class="line"></span><br><span class="line"><span class="comment">//vmresume</span></span><br><span class="line">__emit <span class="number">0x0f</span></span><br><span class="line">__emit <span class="number">0x01</span></span><br><span class="line">__emit <span class="number">0xc3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VMExitHandlerDispatcher</code>函数用于处理<code>#VMExit</code>事件：</p><p><code>ExitReason</code>指定了退出原因。</p><p><code>ExitInstructionLength</code>指定了导致退出指令的长度。</p><p><code>g_GuestRegs.eip = __vmx_vmread(GUEST_RIP);</code>读取了导致退出指令的地址。</p><p>处理完指令的退出后，设置<code>GUEST_RIP</code>为下一跳指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>  <span class="title function_">VMExitHandlerDispatcher</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ULONG ExitReason;</span><br><span class="line">ULONG ExitInstructionLength;</span><br><span class="line">ULONG GuestResumeEIP;</span><br><span class="line"></span><br><span class="line">ExitReason = __vmx_vmread(VM_EXIT_REASON);</span><br><span class="line">ExitInstructionLength = __vmx_vmread(VM_EXIT_INSTRUCTION_LEN);</span><br><span class="line"></span><br><span class="line">g_GuestRegs.eflags = __vmx_vmread(GUEST_RFLAGS);</span><br><span class="line">g_GuestRegs.esp = __vmx_vmread(GUEST_RSP);</span><br><span class="line">g_GuestRegs.eip = __vmx_vmread(GUEST_RIP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ExitReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> EXIT_REASON_CPUID:</span><br><span class="line">HandleCPUID();</span><br><span class="line">Log(<span class="string">&quot;EXIT_REASON_CPUID&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EXIT_REASON_VMCALL:</span><br><span class="line">HandleVmCall();</span><br><span class="line">Log(<span class="string">&quot;EXIT_REASON_VMCALL&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EXIT_REASON_CR_ACCESS:</span><br><span class="line">HandleCrAccess();</span><br><span class="line"><span class="comment">//Log(&quot;EXIT_REASON_CR_ACCESS&quot;, 0)</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">26</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">Log(<span class="string">&quot;not handled reason: %p&quot;</span>, ExitReason);</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Resume:</span></span><br><span class="line">GuestResumeEIP = g_GuestRegs.eip + ExitInstructionLength;</span><br><span class="line">__vmx_vmwrite(GUEST_RIP, GuestResumeEIP);</span><br><span class="line">__vmx_vmwrite(GUEST_RSP, g_GuestRegs.esp);</span><br><span class="line">__vmx_vmwrite(GUEST_RFLAGS, g_GuestRegs.eflags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x07-EPT"><a href="#0x07-EPT" class="headerlink" title="0x07 EPT"></a>0x07 EPT</h3><p>看了一下要重建页表我就不想看了。</p><h3 id="0x08-代码"><a href="#0x08-代码" class="headerlink" title="0x08 代码"></a>0x08 代码</h3><p>这个代码魔改的周壑的<code>VT_Learn</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fiddler证书有效期时长设置</title>
      <link href="/fiddler%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE/"/>
      <url>/fiddler%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>chromium 85 以后，2020-09-01 以后签发的HTTPS TLS 证书的有效期最多不超过398天，这导致fiddler默认的根证书无效，无法抓包。</p><blockquote><p>Beginning with Chrome 85, TLS server certificates issued on or after 2020-09-01 00:00:00 UTC will be required to have a validity period of 398 days or less. This will only apply to TLS server certificates from CAs that are trusted in a default installation of Google Chrome, commonly known as “publicly trusted CAs”, and will not apply to locally-operated CAs that have been manually configured.</p><p>Certificates that do not comply with this requirement will not work, and may cause webpages to fail to load or to render incorrectly.</p><p>If a certificate that does not comply with this requirement is issued by a CA trusted in a default installation of Google Chrome, this will be treated as a failure to comply with the security policies necessary to being a trusted CA, and may result in the removal of trust of that CA’s certificates.</p></blockquote><p>需要重新配置Fiddler的证书有效期</p><span id="more"></span><p>打开Fiddler的选项-HTTPS页面，提示证书由<code>CertMaker.dll</code>签发。</p><p><img src="/./fiddler%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE/Snipaste_2021-12-16_09-11-27.png" alt="证书来自CertMaker.dll"></p><p>把这个<code>CertMaker.dll</code>扔进<code>dnspy</code>里面看一下。</p><p>有两个字段控制了证书的生成时间。</p><p><img src="/./fiddler%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE/a.png" alt="a"></p><p>在<code>QuickExec</code> 执行 <code>about:config</code>（Fiddler抓包界面下面的命令行）<br><code>fiddler.certmaker.bc.ee.yearsvalid</code> 是 有效年份<br><code>fiddler.certmaker.bc.ee.CreatedDaysAgo</code> 是 起始日期<br>这里年份填1，起始日期填-7就行了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
